*to practice/implement js on web, you can use jsbin.com
* alert('Hello World!')
shows the alert box in the browser window

*JavaScript is a high-level, object oriented, multi-paradigm(patterns) programming language. It helps to add dynamic and interactive effects 
to any webpage. It is also used to manipulate the content or the CSS, load data from remote servers and build entire applications in the
browser which we then call web applications.

High-level languages are human-friendly. They are, thus, very easy to understand and learn by any programmer. Low-level languages are machine
-friendly. They are, thus, very difficult to understand and learn by any human.


*Js is highlevel language: which mnz that in languages like C, we have to manually manage the memory by asking for memory from computer but
 in JS we do not have to manage these resources at all. But the downside is, JS program can never be as fast as C.


*JS also cleans up the memory used by our program. We don't have to do it manually.


*JS is an interpreted or Just-in-time compiled language.


*JS is a multi-paradigm language, which mnz it follows all the 3 paradigm/approaches: Procedural Programming, OOP, Functional Programming.


*JS Engine is a program that executes JS code. It consists of call stack and memory heap.


With JS one can also make websites on web server by using node js, which doesn't need any browser at all which helps us to make backend 
applications, which interacts with db. With simply javascript and browser, we create frontend applications. 

We can also build native mobile apps with JS and also desktop applications with the help of react native, ionic, electron.

ES(s) are the versions of the JS and ES stands for ECMAScript and from ES6 to today, its called modern JS. There was big change from ES5 to ES6


*If we write any operation in browser's console, then it will print its result automatically as at that time we are in console. But if we 
write that operation in <script> tag then it will not automatically give the result as at that time we are in script tag and to print 
something on console, we need to put a bridge between script and console and console.log('message'); acts like that bridge.


*Inline Script: In this we write JS code in html file itself, its only advantage is that we don't have to create another file for JS but we 
should use external file for JS logic.
write like this anywhere in your html file
<script>
    console.log('Hello World! from inline code.');
</script>

To link js logic file to html file, we usually do that after the end of the <body> within <script src="script.js"></script>
we need to write the location of the file, if file is in same folder then only name of that file will work.
If we will write code inside script tag along with .js file attached with html file then that code will not get executed, code which is in 
that file will only get executed.
scripts can be placed in the <body>, or in the <head> section of an HTML page, or in both. 

Placing scripts at the bottom of the <body> element improves the display speed, because script interpretation slows down the display.


*We generally use camelCase notation to name a variable in JS. Variable name cannot start with a number. It can only contain letters, numbers
(in between or last), underscore, dollar
sign and we can't use reserved JS keyword as variable names.
Another convention of writing constants variable name is by writing all the letters as uppercase.
JS Reserved words: https://www.w3schools.com/js/js_reserved.asp


*All JavaScript variables must be identified with unique names.
	These unique names are called identifiers.


*You can't name a variable "name" in JS in global scope because without any enclosing scope, var name is window.name, which is a native property
which cannot be replaced or overridden. You can assign any value to it.
In a local scope you can use "name" as your variable name.
> name
< "[object Object]"
> name.anchor
< function anchor() {
    [native code]
}
> name = null
> name
< "null"
> typeof name
< "string"
> name.anchor
< function anchor() {
    [native code]
}


IMPORTANT
*to get date in proper format you can use
const month = (new Date()).toLocaleString('en-US', {month: 'long'}); //Feburary, December
const year = (new Date()).getFullYear(); //2022
const day = (new Date()).toLocaleString('en-US', {day: '2-digit'}); //02, 21
this is basic JS, you can search more about it


*operator precedence table is at:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence
https://www.w3schools.com/js/js_precedence.asp

*var x, y;
x = y = 2 + 4;
console.log(x, y);//o/p = 6 6
bcz = has right to left associativity and + has more precedence
so 2+4 will be 6 and 6 will be assigned to y and then x will be equal to y which is 6
So both will be 6

*In JS every value is either object or primitive type.


*There are 7 primitive data types:
Number: Floating point numbers (used for decimals and integers)
Extra large or extra small numbers can be written with scientific (exponential) notation:
let y = 123e5;      // 12300000
let z = 123e-5;     // 0.00123
String: Sequence of characters (used for text, single quotes or double quotes both will work)
Boolean:
Undefined: Value taken by a variable that is not yet defined ('empty value') (let children; //children variable will contain value as undefined) 
	typeof that variable is undefined.

	var test = undefined;
	console.log(test);
	// undefined

	var test = {};
	console.log(test.prop);
	// undefined

Null: Also mnz empty value. Null is assigned. typeof that variable will show object, this is bug in JS which is never corrected.
Symbol(from ES2015): Value that is unique and cannot be changed.
BigInt(from ES2020): Larger integers than the Number type can hold.


*Referance type values like object, array contains pointer to the location where it's value is present in the heap, that
pointer/address gets stored in stack.


*JS has dynamic typing: We do not have to manually define the data type of the value stored in the variable. Instead data types are determined
automatically. Whereas in other languages you need to determine the datatype of the variable. In JS it is the value that has type, not the 
variables. So variables simply store the values that have type. That is why we can assign a Number value to a variable and later we can assign
String value to that variable without any error.


*typeof operator: tells the datatype of the value or variable holding a value. (typeof true; typeof firstName, typeof 34)


*let and const were introduced in ES6. const variable can never be mutated/changed. Initialization is required in const variable declaration, 
without giving a value, const variable can't be declared. One should generally use const to declare a variable instead of let, its a good 
practice. let should only be used when we are sure that that variable's value will be changed in future. var is the old way of declaring 
variables, it is prety much same as let, difference is that var is function scoped and let is block scoped.
We can also give value to a variable without actually declaring it with let, const or var. But in that case JS will actually use that variable
as a property (of window object(not sure)) which will have global scope.

IMPORTANT
*Variables defined with let cannot be Redeclared.
Variables defined with let must be Declared before use.
Variables defined with let have Block Scope.


*String can be initialised either with single quotes or with double quotes. When we want to use single quotes in our sentence then we can use 
double quotes to initialize our string and vice versa.
const sen = "I'm " + year + ' years old.'; //is perfectly fine; JS will convert year number to string and will concatinate it with other 
strings; we can use single quotes and double quotes at the same time. The only thing which is to keep in mind is if you open with single 
quotes then close with single quotes.

IMPORTANT
*In the last example, to manage all the spaces and + is a problematic work so to avoid this, we can use TEMPLATE LITERAL. 
eg. const sen = `I'm ${year} years old.`; //so we use backticks in this, Automatic replacing of variables with real values is called string
interpolation.


*We can use backticks for a regular string as well.


*console.log('string\nwith multiple\nlines');
output:
string
with multiple
lines

console.log('string\n\
with multiple\n\
lines');
output:
string
with multiple
lines


*as before, we have a shortcut with ``(backticks)
console.log(`string
with multiple
lines`);


*type conversion is when we explicitly converts the type of a value and type coersion is when JS itself converts the type.
const year = '1991';
console.log(year + 18); //199118 type coersion
console.log(Number(year) + 18);//type conversion

console.log(Number('Prateek'));//NaN
NaN (Not a Number): is an invalid number

IMPORTANT
console.log('23'-'10'-3); //10; type coersion
In the operators other than +, JS will convert string to number implicitly 

let n = '1' + 1; // '11'; type coersion from number to string
n = n-1; //11-1; type coersion from string to number
console.log(n); //10

2+3+4+'5' = "95"
'10'-'4'-'3'-2+'5' = "15"


*falsy values: 0, '', undefined, null, NaN
these are the values which become false when converted to boolean implicitly or explicitly. Everything other value converts to true.
false is normally a falsy value.


*if we don't write any logical operation in if condition then JS will implicitly convert value/variable present in parenthesis to Boolean.
if(age){} //JS will convert age to Boolean; if age = 0, null, undefined, Nan, '', false then false otherwise true.


* === is the strict equality operator, it doesn't do type coersion.

'18' == 18 //true bcz JS will do type coersion just to compare
'18' === 18 //false bcz in strict equality operator, type coersion doesn't occur.
For bug less code, prefer strict quality operator and not loose equality operator.


*To take a value from frontend in short, we can use prompt
const favouriteNumber = prompt("What's your favourite number?"); //favouriteNumber variable will contain the entered value as string


*switch statement does strict comparision.
switch can contain string in the case and also the logical expressions (age>13 && age<20).


*An expression is something which produces a value. Eg. 1991, 2+4, true || false, etc.
Statement is a piece of code which doesn't produces/returns a value. Eg. if else statement, switch statement


*ternary operator
age >= 18 ? console.log('wine') : console.log('water');
const drink = age >= 18 ? 'wine' : 'water' ;
here we can see that ternary operator is an expression which returns a value. Operators always make a expression.
we can also add nested ternary operator for eg.
age >= 18 ? (age >= 60 ? console.log('retired') : console.log('workable')) : console.log('minor');


*JavaScript has to do nothing with Java.
JS is backward compatible. Means a JS code written in 1997 can still work in today's browser.
JS contains some old bugs or weird things as the very first version was made in 10 days and ECMA don't remove previous things from JS to 
prevent the breakage of old websites. So those bugs are still there but we can ignore them as JS offers many exciting features with which 
we can play along.

But JS is not forward compatible. Means code from 2089 won't work in today's browsers.

IMPORTANT
Transpiling: process of reducing the version of our code to ES5 bcz user's browser can be of old version and if we have made our code with 
the latest browser then it might create problem in our users browser as we don't have any control over their browser. 
Babel is the tool to reduce the version to ES5 as ES5 is supported by all the browsers. That version conversion can be done before deploy of 
the app to the server which is when our user will be able to use our website.


*to activate strict mode for the .js file, we just have to write
'use strict';
in the first line of the .js file.
We can also activate strict mode for any function or any block, but there is no significant use of that.
Strict mode forbids us to do certain things and second it creates visible errors, which JS doesn't show us normally. So we can easily debug 
them.
For eg:

let hasDriversLicense = false;
const canDrive = true;
if (canDrive)
    hasDriverLicense = true;
if (hasDriversLicense)
    console.log('I can drive.');
//this will not show error in console when strict mode is not there
//whereas it will show error(hasDriverLicense is not defined) in console when strict mode will be there
//vscode doesn't show this error by default

if we will use the words which can be used as a keyword in future which is reserved by JS then strict mode will show the error on console 
where we have used that word. eg: private, interface


*syntax of a function:
//this is function declaration
function age(birthYear){
	return currentYear - birthYear;
}
console.log(age(1998));

//this is function expression/anonymous function; here function acts as a value
we can also say that a function without a name is an anonymous function
const age = function (birthYear){
	return currentYear - birthYear;
}
console.log(age(1998));


*JS Hoisting


*Arrow Function: it is a special form of function expression
const age = birthYear => currentYear - birthYear;
console.log(age(1998));
If we have multiple lines of code in the function, then syntax will be like this:
const yearsUntilRetirement = birthYear => {
	const age = currentYear - birthYear; 
	const years = 60 - age;
	return years;
}
if we have to pass multiple parameters then write all the parameters seperated by commas and in parenthisis in place of birthYear.


*two ways to initialise the array:
const words = ['hello', 'cat', 'dry'];
const words = new Array('hello', 'cat', 'dry');

to know the number of elements in the array, words.length
to get an element at index position 2, arrayName[2]
to print the array, we can directly use its name

IMPORTANT
*here we can change a particular element of the array, you must be thinking how bcz words array is const and const can't be changed, but 
const primitive values can't be changed and array is not primitive.
Therefore you can keep in mind that arrays can be mutated even though it is declared const. But we can't replace the entire array, we can 
change any number of elements. 
Because array(words(here)) hold the address to a location in head where our elements are present and if we add more elements or changes element
then that location of the array doesn't changes therefore value of the array words doesn't change whereas if we assign completley different
array then that array will have different location in head therefore it is not allowed.


*we can keep any type of value in the same array, JS just expects an expression (which gives a value).
const words = ['hello', 'c'+'at', variableName]; is perfectly fine.

IMPORTANT
*to add a new element in the last of the array, we can use push function and that function call returns the length of the updated array. 
words.push('betty');
to add in the starting, words.unshift('betty');


*to remove element from last, words.pop();
this returns the removed element
words.shift() for removing from the front of the array

*words.indexOf(element) //this will return 0-indexed position.
if that element is not present then it will return -1
words.includes(element) just returns true or false
it do strict comparision


*initialise a object
const prateek = {
	firstName: 'Prateek',
	lastName: 'Agarwal',
	age: 2021 - 1998,
	friends: ['raju', 'taj']
};
we can also say that this prateek object has 4 properties(firstName, lastName, age, friends).


*to print this object, we can directly print its name:
console.log(prateek);
to print its property:
console.log(prateek['lastName']);//here we can write any expression which gives the property lastName
console.log(prateek.lastName);


*to check if an object contains a particular key or not
prateek.hasOwnProperty('firstName'); //will return either true or false 

IMPORTANT
if we will extract a property name which doesnt exists in the object, then it will return undefined

we can use bracket notation when we will be extracting the property or taking the property lastName from dom but we can't use the variable name 
or expression in dot notation, it won't extract the value of the variable, it will find the property = variable name.
eg:
const property = 'lastName';
console.log(prateek.property); //undefined
console.log(prateek[property]); //Agarwal


*to give another property(key-value pair) after the initialisation,
objectName.newPropertyName = value;
objectName['newPropertyName'] = value;


*objects can also have object, function expression inside it.
we can use the property of that same object inside its function by this keyword or object name, but we should prefer this keyword as we should
not repeat ourself in the code. 
Other reason is if object name is changed in future then we will have to change it inside the fn as well, but if we will use this then we don't
have to change anything inside the fn


*another way of creating an object
var objJane = new Object();
objJane.firstName = 'Jane'; and so on we can give different key-value pairs
This is called new object syntax


*we can add a function expression in the object as follows:
var objJohn = {
	firstName: 'John',
	lastName: 'Smith',
	birthYear: 1990,
	family: ['Jane', 'Mark', 'Bob', 'Emily'],
	job: 'teacher',
	isMarried: false
	calcAge: function(birthYear){
		return 2020 - birthYear;
	}
};
To access it, we write objJohn.calcAge(1990);

*or we can access the same property inside the function, just like
calcAge: function(){
	return 2020 - this.birthYear;
}


*method borrowing: if we want one object's method to be same as the other object's method then we borrow another object's method.
mike.calculateAge = john.calculateAge; //where calculateAge is defined in john object and at this line mike will also have the method named 
calculateAge and will be same as john's calculateAge method.

IMPORTANT
we can also call john object's method as if it is part of mike object like john.calculateAge.call(mike); //this will call calculateAge with
'this' pointing to mike object as we have passed mike object as the argument

IMPORTANT
with the call method to any function, we can pass the object in the arguments, that method's this will point to that passed object, we don't 
need to add any parameters to that function. If we want to pass any other argument to that function, then we can pass it normally after the
first argument which will always be the object which 'this' will be pointing to, in the function definition we just have to add parameter for
the second argument
eg.
let printFullName = function (country) {
	console.log(this.firstName + " " + this.lastName + " from " + country);//this will point to mike object, country will be India as called below
}

printFullName.call(mike, "India");

IMPORTANT
*.apply is just same as .call only difference is along with object we need to pass array of other arguments instead of individual values.


*.bind is also kind of similar to .call, it just returns the function binding it to the object passed as an argument, it doesn't call the
method, it will just return the function which can be called later


*we can call functions(push, pop) on an array, so we can say that array also has property as objects. This means array is also an object. So 
we can say that array is a special type of object (about which we will discuss later).


*how to create an empty array:
const types = [];


*console.table(objectName); can be used to display the object on the console


*A better way to do a manual testing is done through Sources tab of developer tools. By setting the breakpoints, we can see the values being
passed and set at each step live while program is running. It will be a type of dry run only just we don't have to write values at every step.
We can also put a breakpoint in our code by writing 
debugger:
at that point where we want to add breakpoint.


*to select an element of dom in .js file:
document.querySelector('.itsClassName').textContent
There are other ways of selecting elements as well.
For input field, we use .value instead of .textContent


*Remember to use .(dot) before the class name in the selector. We don't use .(dot) and #(hash) in getElementByClassName and getElementById respectively.


*DOM Manipulation: It is basically a process where .js file interacts with the dom(browser window).


*DOM(Document Object Model): Structured Representation of HTML documents. Allows JS to access HTML elements and Styles to manipulate them.
DOM is not the part of JS language. Web apis include Dom methods and properties and Web apis are the libraries which are written in browsers
 and JS. There are many more apis like timer and fetch apis which we will learn later.


*Event Listener: document.querySelector('.itsClassName').addEventListener('click', function(){
	//logic to run after clicking that button or element on which click event is attached
});
This function here will be called event handler, which handles the click event.


*Input field returns a string.


*Change styling from .js file:
document.querySelector('body').style.backgroundColor = '#342321'; 
We have to assign a string, no matter what value we have to assign to the style property
If we have two words in style property then in .js file we should write in camelCase notation.
document.querySelector('.number').style.width = '30rem';
These are the inline styles


IMPORTANT
*If we have more than one element containing same class then document.querySelector('.className') will contain the first element.
If we want to address every element then we need to use document.querySelectorAll('.className') and this will contain the array of each 
element and we can address each one with the index position from that array.


*Remove class from an element from .js:
const myVariable = document.querySelector('.className');
myVariable.classList.remove('hidden', 'class2');
Note: here in this we do not include .(dot) before the class name.


*Similarly we can add class by using add() in place of remove();


*apply global event listner
keypress event is a global event listner, to listen to keypress event:
document.addEventListner('keydown', function(e){
	//'e' is an object which will contain the value which will tell which key is pressed
	//e.key will contain that keyboard key name; you can print 'e' to get all the key value pairs.
})


*imageElementVariable.src= "image.png";


*JS use just-in-time compilation which is combination of both compilation and interpretation. This approach compile the whole code at once 
and then run it right away but it doesnt produce the portable file(machine code) in between. It optimises the part of a code and executes 
it and in that time optimises another part of the code in another thread.


*Just after compilation, creation of global execution context(EC) (for top-level code(code which is outside any function)) happens.


*Execution Context: Environment in which a piece of JS code is executed. Stores all the necessary information for some code to be executed. 
This contains variables(let, const and var declarations, functions, argument object), scope chain, this keyword.


*IMPORTANT: EC of arrow functions do not have argument array and this keyword but we can pass individual arguments normally as we do.


*then execution of top-level code(inside global EC) happens. Finally the Execution of functions and waiting for callbacks and EC are created
 for all the functions.


*JS follows Lexical scoping(scoping is controlled by placement of functions and blocks in the code from top to bottom).

IMPORTANT
*Variable lookup: it is the process in which compiler looks for a variable in the outer scope if inner scope has used that variable and 
doesn't have that variable in inner scope. 
If compiler finds that variable in the outer scope, then it will use its value and if not then it will look more outer of that outer scope 
and if compiler still doesnt finds that variable till the global scope then it will throw an error.


*var variable is function scoped which mnz that even if a var variable is declared inside a block, it can be accessible in the function in 
which that block is. But let/const variable declared inside a block will only be accessible in that block, not in the function in which that
block is.

function checkScope(){
  if(true){
    var varVariable = 10;
    let letVariable = 20;
    const constVariable = 30;
  }
  console.log(varVariable);//accessible as var variable is function scoped
  console.log(letVariable);//not accessible
  console.log(constVariable);//not accessible
}

checkScope();
console.log('var in global scope: '+ varVariable);//not accessible


*var a = 'Hello! ';
first();

function first() {
    var b = 'Hi! ';
    second();

    function second() {
        var c = 'Hey!';
        console.log(a + b + c);//Hello! Hi! Hey!
    }
}
whereas
var a = 'Hello! ';
first();

function first() {
    var b = 'Hi! ';
    second();

    function second() {
        var c = 'Hey!';
        console.log(a + b + c);//undefinedHi! Hey! a is undefined bcz we have defined a in this function therefore EC of this function
		//contains a with value as undefined as we have initialised 'a' after this line, until which a will hold undefined in EC, so 
		//compiler found 'a' in inner scope itself but with a value undefined
        var a = 'Bhak';
    }
}


*functions are also block scoped. But this is only true for strict mode.

IMPORTANT
*Hoisting: Makes some types of variables accessible/usable in the code before they are actually declared. "Variables lifted to the top of 
their scope". But behind the scenes before execution, code is scanned for variable declarations, and for each variable, a new property is 
created in the variable environment object(or global EC).


*Function Declarations are hoisted and is blocked scope.

IMPORTANT
*var variable is also hoisted, it is function scoped, and its initial value is undefined. That mnz if you use a var variable before its 
declaration/initialisation, then it can be accessed but its value will be undefined.


*let and const variables are blocked scoped. Actually it stays in temporal dead zone(TDZ) in its scope. If you use a 
let or const variable before its declaration in its scope then you will get different error(cannot access variable before its initialization)
 as compared to error(variable is not defined) which we get if we use variable which is not declared in the entire code.
One will get the same error(variable is not defined) if we use that variable outside its scope.
TDZ was introduced to get the clear error msg and to debug the code easily.

*const keyword does not define a constant value. It defines a constant reference to a value.

Because of this you can NOT:
Reassign a constant value
Reassign a constant array
Reassign a constant object

But you CAN:
Change the elements of constant array
Change the properties of constant object


* Exponentiation operator: 2**3 = 8


*If you add a number and a string, the result will be a string!
let y = "4" + 5 + 2; //452
JavaScript evaluates expressions from left to right.
let y = =5 + 2 + "4"; //74
In the first example, since the first operand is a string, all operands are treated as strings.


*Function expressions and arrow functions depends on the way(let or const or var) with which they are defined and will work according to its
(let or const or var) properties.


*Ideally we should not use hoisting in case of the variables as it could create bugs if not used carefully. Basically hoisting was introduced
 for functions and hoisting in var variables are a biproduct of it. To work around this, we use let and const variable in modern JS.


*'window' is a global object.


*variable created with var makes its property in window object whereas let and const doesn't. (Just an info doesn't really mean bcz var is 
not used in modern JS).

IMPORTANT
*'this' is not static. It depends on how the function is called, and its value is only assigned when the function is actually called.


*'this' points to window's object everywhere except inside the object. Inside an object, if 'this' is accessed then it will point to the 
object.

	1: function is called by an object.
	const jonas = {
		name: 'Jonas',
		year: 1989,
		calcAge: function() {
		 return 2037 - this.year;//this pointing to object jonas
		}
	};
	jonas.calcAge();//fn is called by an object

	So in this case, 'this' points to the object. Therefore this used in that function meant the value of the variable(year) in that object.

	2: Normal function call.
	'this' is undefined in strict mode but points to global object(window) in non-strict mode but that can be very problematic.

	3: arrow functions
	this = this of surrounding function (lexical this keyword) mnz 'this' of the outer scope as arrow fns do not get their own this keyword.

	4: event listner.
	this = DOM element that the handler is attached to

	5: new, call, apply, bind.
	later


*Note: 'this' never point to the function in which we are using it and also never to the variable environment of the function.

IMPORTANT
*curly braces in object creation doesn't creates a scope, its just the way by which we define object.


*In this example, the code changes the content of its own element as eventlistner points this to the it's dom element
<button onclick="this.innerHTML = Date()">The time is?</button>


*to get length of the string
let text = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
let length = text.length;


*Comparing two JavaScript objects always returns false.

*let text = "HELLO WORLD";
text[0] = "A";    // Gives no error, but does not work
//you can just read character at position 0
let x = text[0]; //H


*string methods: https://www.w3schools.com/js/js_string_methods.asp

IMPORTANT
*If we dont know how many arguments are gonna be passed into our function then we can use 'arguments' array in that function or can loop 
through that array and it stores the arguments passed into that function in different index positions. But arguments keyword/array does not
exist in arrow functions.


*Primitives are stored in call stack(to be precise, execution context).
Objects: Object literal, Arrays, Functions and many more. They are called reference types. Their values are stored in heap.

IMPORTANT
*value at a certain memory position cannot be changed, if we change value of a variable then a new memory is generated and new value is kept
in call stack.


*const reference variable's value can be changed later. As reference variable has value = address where its value is stored in heap. So by 
changing the value of the const reference variable, we change the value in call heap, we don't change its address(which can't be changed of 
const reference variable). What needs to remain constant is the value its holding in call stack, which we are not changing.
We cant change the whole object, we can change its property or can add or remove a property from that object.

IMPORTANT
*const objectCopy = Object.assign({}, objectName);
this makes a shallow copy of the object objectName, which mnz that if we change a normal value of that object then it will be 
just changed for that object, not for both the objects. But this doesn't work with objects under these objects. For eg, if we
have array in the first object (objectName here) so for object objectCopy, new array won't be made, pointer to the same array
in heap will be pointed by the key of objectCopy as well. Therefore if we will do any changes in the array of the first obj
then that change will still be displayed to the current object.

If we think logically then it is very obvious, as in both primitive types or reference types(arrays) new object's keys will point to the value
in call stack, when we change any primitive value of the old object, then that new value is given a new memory in call stack and key of the
previous object starts pointing to that new location, key of the new object is still pointing to the old location and therefore that old
value is not deleted from the memory whereas in the case of arrays or reference types, new key is pointing to the address to the array as
in the case of primitive type, but now if previous object will change array element then address in callstack won't change therefore that
changed value is reflected in new object as well.

to make shallow copy of array, var myHobbies = person.hobbies.slice();


*Traversing array arr
arr.forEach((ele, i) => {
	//code
	//i gives the index of the array at ith iteration and ele gives the element at ith position
}
));


*Destructuring an array
const arr = [2, 3, 4];
const [x, y, z] = arr;
console.log(x, y, z); //2 3 4

//only first & second
const [a, b] = arr;
console.log(a, b); //2 3

//only third
const [ , , c] = arr;
console.log(c); //4

//giving default values
[a=1, b=1, c=1] = [3, 6];
console.log(a, b, c); //3 6 1


*Destructuring object
const student = {
	name = "Raj",
	city = "Noida",
	rollno = 23,
	sex = "male"
};

const {city, sex, name} = student; //here we have to give the exact key
console.log(name, sex, city); //Raj male Noida

//but if we want to use another variable name then
const {city: cityName, name: studentName} = student; //name is the key and studentName is the new variable name

//giving default value
const {menu = [], subjects: subs = []} = student; //here it is supposed that menu or subjects have array as a value in student object


*Spread operator (it spreads the array elements)
const arr = [1, 3];
const newArr = [0, 2, ...arr];
console.log(newArr); //[0, 2, 1, 3]
if we want to log individual elements of an array then also we can use spread operator
console.log(...newArr); //0 2 1 3


*Iterables: arrays, strings, maps, sets (NOT objects)
we can use spread operator on all Iterables, it spreads each character of string seperately.
Spread operator also works on objects


*Using document.write() after an HTML document is loaded, will delete all existing HTML. Example if we will write document.write() on click of
a button then after click of that button, all the existing HTML will get deleted from the browser window and just that document.write() will
display it's output.


*Fixed values are called Literals.
Therefore we initialise variable with a literal.
let x = 34; //34 is literal and x is variable

JavaScript does not interpret LET or Let as the keyword let. JS is case sensitive.


*You can call the window.print() method in the browser to print the content of the current window.


*JavaScript will try to convert strings to numbers in all numeric operations except in +(addition)
let x = "100";
let y = "10";
let z = x / y; //10 
console.log(typeof(z)); //number
//JS uses + operator to concat the strings


*let x = 100 / "Apple"; //NaN, number
let x = 100 / "10"; //10, number


*All about numbers, https://www.w3schools.com/js/js_numbers.asp

IMPORTANT
*fixed number of decimals:
let x = 9.656;
x.toFixed(0); //10
x.toFixed(2); //9.66
x.toFixed(4); //9.6560
x.toFixed(6); //9.656000


*In case of our custom function in sort,
const points = [40, 100, 1, 5, 25, 10];
points.sort(function(a, b){return a - b});
When the sort() function compares two values, it sends the values to the compare function, and sorts the values according to the returned 
(negative, zero, positive) value.

If the result is negative(which means b is greater than a, by default functionality is to sort ascending, therefore if we want sorting in
descending order then we can return b - a in this case), a is sorted before b.

If the result is positive, b is sorted before a.

If the result is 0, no changes are done with the sort order of the two values.


*JS History: https://www.w3schools.com/js/js_history.asp


*By default, JavaScript will use the browser's time zone and display a date as a full text string
JavaScript counts months from 0 to 11.
Date format: https://www.w3schools.com/js/js_date_formats.asp


*This JavaScript function always returns a random number between min (included) and max (excluded):
function getRndInteger(min, max) {
  return Math.floor(Math.random() * (max - min) ) + min;
}


*When comparing a string with a number, JavaScript will convert the string to a number when doing the comparison. An empty string converts 
to 0. A non-numeric string converts to NaN which is always false.


*The Optional Chaining Operator (?.)
The ?. operator returns undefined if an object is undefined or null (instead of throwing an error).


*If default is not the last case in the switch block, remember to end the default case with a break.

IMPORTANT
*A JavaScript Set is a collection of unique values. Each value can only occur once in a Set.

You can create a JavaScript Set by:
Passing an Array to new Set()
Create a new Set and use add() to add values
Create a new Set and use add() to add variables

const letters = new Set(["a","b","c"]);
OR
// Create a Set
const letters = new Set();
// Add Values to the Set
letters.add("a");

IMPORTANT
*A Map holds key-value pairs where the keys can be any datatype. A Map remembers the original insertion order of the keys.

You can create a JavaScript Map by:
Passing an Array to new Map()
Create a Map and use Map.set()

const fruits = new Map([
  ["apples", 500],
  ["bananas", 300],
  ["oranges", 200]
]);
OR
// Create a Map
const fruits = new Map();
// Set Map Values
fruits.set("apples", 500);


*If you assign a value to a variable that has not been declared, it will automatically become a GLOBAL variable.
This code example will declare a global variable carName, even if the value is assigned inside a function.
myFunction();

// code here can use carName

function myFunction() {
  carName = "Volvo";
}
//but in strict mode this will throw error


*With arrow functions the this keyword always represents the object that defined the arrow function.


*class Car {
  constructor(name, year) {
    this.name = name;
    this.year = year;
  }
}

IMPORTANT
*Arrays with named indexes are called associative arrays (or hashes). But JS doesn't allow array with named indexes.


*Default export: a file can have only one default export. The file which imports that doesn't need to give exact name of the variable.
Whatever name will be given will contain that default exported data.
export default person;
import prs from './persons.js';
import {baseURL} from './utility.js'; //importing normal/named exported data from file utility.js
//other import statements for normal/named exported data
import {fullname as name} from './utility.js';
import {firstname, lastname} from './utility.js';
import * as bundled from './utility.js'; //bundled will be object which will contain all the normal/named exported data of file utility.js


*let name = "Prateek";
let firstname = name; //this is primitive type, here it will just copy the value of name


*const person = {
	name: 'Prateek'
}

const another = person; //this is reference type, here it will copy reference of person object, therefore if we will change person object 
then another object will also gets changed.
this acts the same for arrays

but with spread operator, only properties will get copied not the whole object reference

****************************************Namaste JavaScript***************************************************

*Everything inside JavaScript happens inside Execution Context
Execution context has two parts:
1: Variable Environment(Memory Component) where all the variables and its value and functions and its definition is stored in the form of 
key-value pairs.
2: Thread of Execution (Code component) where whole code is executed one line at a time in a synchronous manner (in certain order) in single
thread at a time.
Execution context is created in two phases, first phase is known as memory creation phase.
In the First phase, JS stores undefined as a value of all the variables present globally and stores function name and whole function body.
Second phase is the code execution phase: in this phase JS runs code line by line and allocates value to the variable(if defined) in 
Variable Environment(Memory Component).
That mnz even before code is executed in JS, memory is allocated to the variables and functions.

When we invoke a function in our JS code and when JS goes to that line, a brand new Execution Context is created for that function as function
acts like a small program in our JS program.
In function's execution context, parameter of a function is also considered as a variable and therefore undefined is kept as a value in it's
first phase.
Once JS runs the return statement of the function in the second phase, after that it automatically deletes the execution context of that function.

JS manages these Execution context with the help of a call stack, keeping global Execution context in the bottom.
Call stack manages the order of execution of Execution Context.


*If we console log the function name then it will print complete function(body)


*In case of arrow functions and function defined with var, first phase of execution context treats arrow function as a normal variable and 
therefore initialise it with undefined.
Whole body of function goes as a value of the function name to the memory allocation phase only for normal function definition.
All this is known as Hoisting. What value variable stores and function stores before the execution of the code all defines Hoisting.


*window is a global object which is created along with Global Execution Context.
'this' is created along with every Execution Context but 'window' is created only with Global Execution Context.
'this' created with Global Execution Context is === 'window'

Whenever we create any variable or function in global space then they get attached to the 'window' object.


*undefined acts like a placeholder to our variable until that variable is initialised(given value).
not defined comes when a variable is not assigned any memory in phase 1 of Execution Context or we can say it was not declared in that scope.


*JS is a loosely/weakly typed language, which means that a variable is not strictly given a type, if a variable is given boolean value at 
first then later in the code, string value can also be given to that same variable.


*Lexical Environment is the local memory(memory component) along with lexical environment of it's parent.
So in phase 1(Memory component) of Execution Context, along with variable and function you also get address of the lexical environment of its
parent.
Global Execution Context have null as it's address of lexical environment of it's parent as there is no parent of Global Execution Context.

This chain of Lexical Environment is known as the Scope Chain.

IMPORTANT
*let and const are also Hoisted, but they are not assigned memory space in Global Execution Context.
They are assigned memory somewhere else which we cannot access with global object util it is initialised with a valid value in our code.
Temporal Dead Zone is the time between which a let/const variable is assigned memory(Hoisted) and the time at which it is declared.
That mnz Temporal Dead Zone for a variable ends after initialisation of that variable.
You can't access a variable in it's Temporal Dead Zone.


*In case of reference error, JS runs the code till the line at which reference error is coming, but in case of syntax error, JS won't run
a single line of code and will just throw that error.


*We can redeclare same 'var' variable in the same scope but we can't do that with 'let' and 'const', JS will throw a syntax error in case
of let and const.


*block is also known as compound statement.
block can be used to combine multiple statements in a place where JS expects a single statement. Eg. JS expects a single statement after if
but if we have multiple statements to write then we can add them in a block, basically in a curly braces which we usually do.

block scope mnz what all variables and functions we can access inside that block.


*variables declared as let and const globally are assigned memory in a sperate space(Syntax in inspect) and let & const variables declared
inside a block/function are assigned memory in a seperate space(Block in inspect).


*we can shadow a var variable with a same let variable inside block scope but we cannot do vice versa. To explain that even better, we
can say that if a variable is shadowing any other variable then the shadowing variable should not cross the boundries/limits of the shadowed
variable. Therefore as let/const is strict(have some boundries/limits) but var is flexible, var cannot shadow let/const variable so it crosses
let/const variable's boundry. This is known as illegal shadowing. One more reason could be that we cannot redeclare let/const variable but 
we can do that with var variable. 


*but var can shadow let/const inside function scope. That is not illegal shadowing.
*all the scope rules working for functions, works the same way for arrow functions.

IMPORTANT
*Function along with its lexical scope is known as Closure.


*When function is returned from another function, they remember their lexical scope (their memory content addresses, their parent memory 
content addresses and so on even if their parent or it's parent existance is now gone)
Therefore we can say that when a function is returned from it's parent function then that function's closure is returned.

function x(){
	var a = 7;
	function y(){
		console.log(a);
	}
	return y;
}
var z = x();
//at this point existance of x() is gone
console.log(z); //this will print complete y()
z(); //this will print 7 bcz in the above line closure was returned from x() i.e y() and it's lexical scope therefore we can say that y()
is still holding it's lexical scope address.


*setTimeout(function(){
	console.log(i);
	}, 3000);
JS will run function after 3000ms, when JS will run the setTimeout line then it will send the fn somewhere in the memory for that particular
time(3000 mili secs here) and move ahead with its execution, after 3000 mili secs this function will come back into the call stack if call
stack is empty otherwise it will wait in queue until call stack gets empty, when it will come in call stack then JS will run this fn.

IMPORTANT
*function x(){
	for(var i=1; i<=5; i++){
		setTimeout(function(){
			console.log(i);
		}, i*1000);
	}
	
	console.log("Namaste Javascript");
}
x();
//output
Namaste JavaScript
6
6
6
6
6
bcz fn remembers it's lexical scope's address, i.e it will remember i's address and when the time comes of running the fn 5 times till that
time all the iterations of loop will be done and therefore i's value is 6 by that time.

in order to fix it, we can use let inside for loop, as let has boxed scope therefore for every iteration i will be a different variable.


*Smart Garbage Collection: In latest browsers, JS engine sends the variables for garbage collection which are not used by the inner function
in the case of closure.
eg.
function outer(){
	var x = 10, y = 20;
	function inner(){
		console.log(x);
	}
	return inner();
}
outer();
//so in this case, JS engine will clear the space occupied by 'y' after 'outer' function scope is over, but not 'x' as it is used in 'inner'
function and it is forming closure with 'outer' function.

IMPORTANT
*Function Statement/Function Declaration:
function a(){
	console.log('a called');
}

Function Expression:
var b = function(){
	console.log('b called');
}

difference between them comes at the time of hoisting. If we call both of them before their definition, then 'a' will be called normally but
'b()' will give error because at the time of hoisting, b is given value as undefined as it is a var variable in the first phase of Execution
Context.

IMPORTANT
*Named Function Expression
var b = function x(){
	console.log('hello');
}
b();
x();//error as x is not available in the Global Execution Context, but we can use x() inside function x()


*First class functions/citizens: when a function is treated as a value and passed as an argument to another function or returned from another 
function, this ability is known as first class function.


*Callback function: A function which you pass into another function is known as callback function.
function passed in setTimeout function call is a callback function.
Any function which we perform on click of any button or anything is also a callback function. When we click that button then that function
comes inside the call stack and then it gets executed.


*Everything in JS is executed through call stack which you can also call as main thread.


*data hiding: to hide a data, it is generally declared and initialised inside a function and used inside that fn's inner function which forms
closure, therefore whenever operation needs to be performed on that hidden data, then inner function is called, which can access hidden data
//eg to count number of times a function is clicked
function attachEventListner(){
	let count = 0; //hidden data
	document.getElementById('clickMe').addEventListener('click', function xyz(){
		//this function forms a closure and can access hidden data
		console.log("Button clicked ", ++count);
	});
}
attachEventListner();
//JS holds on the clousure and it's scope as anytime that button can be clicked and that count will be required. Which is a overhead.
Better practice is to avoid too many event listeners.


*DOM Apis: all the calls with document.call() are DOM Apis. Eg. document.getElementById()

IMPORTANT
*As we know that in setTimeout, JS engine sends the callback fn to setTimeout web API of the browser and api sends the callback function to
web api's environment and attach timer to it. After that timer gets expired then that callback function is sent to callback queue then
after that, Event Loop checks the callback queue and whatever it finds any callback fn, it sends to the call stack and then it gets executed.
In the background, call stack creates the execution context of the callback function and then executes it in it's second phase.

To see event loop in action, you can check out jsv9000.app


*Event Loop keeps checking the call stack, callback queue and microtask queue, whenever Event Loop see that call stack is empty and there is 
callback function in microtask queue(first priority) or callback queue then it sends that callback function to call stack.
Event Loop will give chance to callback fns of callback queue only when microtask queue is empty.


*Callback/Task Queue: is needed bcz if multiple events gets done in high speed then that queue will store callback functions of all those events
and whenever event loop will see call stack empty then it keeps on sending those callback functions to the callstack one by one in First 
Come First Serve manner.


*Microtask Queue: It is just same as Callback Queue but has higher priority. Callback functions which come from promises (eg from fetch web 
api) and from mutation observer comes under this microtask queue. Therefore, event loop will first send the callback function from microtask queue to call stack and 
then will send callback function of callback queue(if any) to call stack.


*Sometimes it happens that callback fn from microtask queue itself creates another callback fn in microtask queue on execution and this goes 
on and on for sometime, then in that case callback fn from callback queue will not get executed for sometime, this situation is known as
Starvation for callback fns in callback queue.


*Wherever you want to run your JS code, you will need Javascript Runtime Environment, which contains JS Engine, APIs, Event Loop, callback
queue, microtask queue etc.


*When code goes into JS Engine, it goes through 3 levels, Parcing, Compilation and Execution.
Parcing generates Abstract Syntax Tree(you can see AST of your code on astexplorer.net) out of our code and sends it to the compilation 
phase.
Compilation phase uses Just In Time (JIT) Compilation, which uses both interpretter and compiler to compile the JS code. It depends on 
different JS engines, how they are compiling our JS code using interpretter and compiler. After compilation, it converts our code into bytecode.
The Third phase, Execution phase cannot executes the code without memory heap and call stack.


*There are many optimization techniques used by different JS Engines, most famous ones are Inlining, copy elision, inline caching you can
read about them.


*JS Engine contains Garbage Collector as well which follows Mark & Sweep Algorithm to clean up the unused memory in our code.


*Higher order function: A function which takes another function as an argument or returns a function is known as Higher order fn.
A function which is passed into that higher order function is known as callback function or first class functions.

IMPORTANT
*array.map returns transformed version of the array(on which map is called) by going through it's elements one by one, it doesn't change
the elements of the array on which map is called


*array.filter returns array which is filtered from the array on which filter is called, on some filter condition, if the callback function
returns true then the filtered array will contain that element of the original array otherwise not.


*array.reduce is used in the place where we want to use all the elements of an array and come up with a single answer eg. to find sum or max
eg. const output = arr.reduce(function (result, current) {
		return result + current; //in case of sum of all elements
	}, initialValue); 
//initialValue is the initial value which we want to give to our result (0 in case of sum)


*we can chain above three functions as well. eg if there are array of objects in which we want array of firstnames of people whose age is
18+
with filter we can get the array of objects whose age is 18+ and then with map we can get the firstnames of those people from the filter
result array

const result = arr.filter((obj) => obj.age > 18).map((obj) => obj.firstName);
we can do the same thing with reduce as well:
arr.reduce(function (result, current) => {
	if(current.age > 18){
		result.push(current.firstName);
	}, []);
	
	
*Polyfill for any method: is the method of writing our own implementation of any predefined function of JS like .call/.apply/.bind as some 
browsers doesn't support some of these methods


*Prototype: is a technique through which javascript binds properties of one object into other object/variable/method. Normally when we call
arr.length then how does our array 'arr' get access to 'length' that is because JS has attached the properties of object '__proto__' to our
array in this case


*prototype chain: arr.__proto__ = Array.prototype
				  arr.__proto__.__proto__ = Object.prototype
				  arr.__proto__.__proto__.__proto__ = null
we should never modify our prototype normally as it hampers our application performance to great extent
if we access any property on an object, it will first search for that property inside the object, if it doesn't find that property then it
will search it in that object prototype (i.e obj.__proto__) if not then again on one above level (i.e obj.__proto__.__proto__)


*Function.prototype.prototypeMethodName = function(){}
if we write any function as Function.prototype then all the methods(as we have made Function.prototype, we can make Object.prototype as well)
in our JS code has access to that method when we call this prototype method with any other method (like otherMethod.prototypeMethodName()) 
then 'this' inside that prototype method will point to that otherMethod this concept helps in polyfill of any method
This stores our methodName to the Function.prototype therefore whenever any random function will try to access methodName then JS will search
it in the scope of that function if not found then it will find it inside the scope of our function.__proto__ which is Function.prototype


*if we don't know how many arguments will be passed into our function then we can put array in the parameter which will contain
all the arguments passed starting from index 0 as follows:
function myFun(...args){
	//here we can use array args to get the arguments
}

*to remove spaces from left or right size of the string
let str = "   Hello ";
console.log(str.trim()); //Hello
this will not change the original string, it will just return a new string


*Polyfill of .bind function
Function.prototype.myBind = function(...args) {
	let fn = this;
	params = args.slice(1); //this will return array of arguments passed into myBind function
	return function(...args2){
		fn.apply(args[0], [...params, ...args2]);
	}
}

let functionName = func.myBind(obj, "abc", "def");
functionName("ghg"); //these arguments will go to args2


*to get index of the element in which traversing it by .map:
projects.map((project, index)=>{
	//code which can use index
	});
	
	
*to get index in case of forEach loop

projects.forEach((project, index) => {
    //code which can access project and index
});
*Function Currying: is the method of converting function with multiple arguments to functions with single arguments. We can do that by two
methods, one by .bind method and second method is through closures

let multiply = function(x, y) {
	console.log(x*y);
}

let multiplyByTwo = multiply.bind(this, 2); //this is known as function currying by bind
multiplyByTwo(3); //6

let multiply = function(x) { //this is known as function currying by closures
	return function(y){
		console.log(x*y);
	}
}
let multiplyByTwo = multiply(2);
multiplyByTwo(3); //6


*Debouncing: is a technique of retricting the call of a time consuming function frequently, by delaying the execution of that function and
canceling the last function call if it is called again frequently to avoid unnecessary CPU cycles, API calls and improve performance.

eg. when we search anything in the search bar, then for the suggestions we have to call an api but if api will be called at every key stroke
then it will highly affect the performance, in this case we can use debouncing, to restrict the api call, we can call the api everytime
when there is a particular delay in the next key stroke.

Logic behind it will be, at every key stroke we will send a function to setTimeout with particular delay and at every next key stroke we
will clearTimeout of the last setTimeout(basically we will cancel last setTimeout callback fn), if the next keystroke will be after that 
particular delay then it obviously can't clear the last timeout and therefore last api call will be done but if next key stroke will be hit 
before that particular delay then it will clear the last timeout.

const getData = () => {
	//main function
	console.log("Fetching Data from API..."+);
}

let magicFn = (d) =>{
	let timer;
	return function(){
		//function that is making debouncing possible
		clearTimeout(timer);
		timer = setTimeout(()=>{
			getData();
		}, d);
	}
}

let betterFn = magicFn(300);

Other usecases involve, on scrolling of the page, on resizing the browser window etc


*Throttling: is also the process of limiting the function calls which happens very frequently otherwise it hampers the app performance.
In this we make another api call after a particular time period, we don't consider the time in which user performs another action.

Usecase would be when we want to know how much time user has resized the browser window, if we do that normally then on one resize, resize
event gets called 100s 1000s of times and therefore our method will be called 100s 1000s of times.
It will execute the method the first time when event occurs then it will ignore all the events occured between that time period and will
again execute our method after that particular time period

Another better usecase can be when a user is clicking a button multiple times very frequently, then in the case of debouncing, we won't be
able to call our method for a longer time until user stops as the time between the next click of the button would be very small in most of
the cases, here Throttling will perform better, no matter how fast user will click the button, throttline will call our method after a
particular time.
Same eg can be of a shooting game, as gun have a particular time after which they can be fired after a particular shot, so in that case as
well, no matter how fast a user is shooting that gun, it will only fire bullet(or our method) after that particular time.

const throttle = (fn, limit) => {
	let flag = true; //this will not reinitiase the variable everytime
	console.log("before return"); //this will be only called once at the time of compilation of the whole code, this will return the function to the place where it is used
	return function(){
		console.log("value entered!");//this will be consoled at every key pressed
		if(flag){
			getData();
			flag = false;
			setTimeout(()=>{
				flag = true;
			}, limit);
		}
	}
}


*async, defer are the boolean script attributes which are used in script tag to optimise the load of external script to the web page
When you load a webpage, there are two things happening in your browser, 1. HTML parcing 2. Loading of the script(which again is divided into
two steps one is fetching the script from network second is executing the script line by line)

1. normal scripts: while html parcing is going on, browser encounters the script tag, html parcing will stop, browser will fetch the script
and when scripts are fetched, browser will execute them, then after execution of the scripts browser will continue with the html parcing.

2. scripts with async: while html parcing is going on, when browser encounters the script tag, browser will start fetching the scripts from
server along with html parcing, when fetch will be completed, html parcing will stop and browser will execute the scripts, html parcing will
continue once execution of the scripts is done.

3. scripts with defer: while html parcing is going on, when browser will encounter the script tag, it will start fetching the scripts along
with html parcing, once html parcing is completed then only browser will start the execution of those scripts.

async attribute doesn't garentuee the sequence of the execution of the scripts, if we have multiple scripts and all have async attribute in
it and mostly are interdependent but as async doesn't guarantee the sequence so our code might break
but defer does guarantee the sequence, so we should use defer in above senario, in most of the cases defer is preferred


*whenever client wants to do any post call to the server side then first a preflight call is made by the browser which is also known as
options call, then server's responsibility is to verify that whether that api call is valid or not, if it is valid then server will set some
additional http headers with which browser will know that the api call is valid and then browser will let client do the actual api call
most common headers are Accept-Contol-Allow-Origin: which contains the urls or * which means that url can make api call to that server,
Accept-Control-Allow-Method: which contains the methods which are allowed like get, put, post etc

But browser doesn't do this option/preflight call for every api call, it does that only for some specific api calls
When we get CORS error then it is because server has not set those headers, if server sets them then we don't get CORS error
CORS: Cross Origin Resource Sharing


*In cookies we can just store 4000 bytes of data but in session storage we can store 5 Mb of data, local storage is same as session storage
it's just that local storage doesn't clears itself automatically unlike session storage even if we close the browser tab/browser/his system
local storage won't get cleared for that origin(protocol(http),host(flipkart.in),port(8080)) for which it is set
local storage has the highest memory capacity

generally the information which are not that relevant to store into the server are stored in local storage for the optimization of the app
bcz server calls will be reduced and data can be easily taken from local storage.


*If we want to store object inside local storage then we can do that by storing JSON.stringify(obj) as it will return that object as a string
When we will fetch that obj then we can do that by JSON.parse(localStorage.getItem(key)); //this will convert the stored string(JSON object
as JSON object is a string at the end) to javascript object(from which we can access key-value pairs)

IMPORTANT
*Event Bubbling & Capturing/Trickling are two methods of propogating down the DOM tree.
In Event Bubbling, if user clicks the child div then first onClick event of child gets hit first then onClick event of it's parent gets hit
then onClick event of it's grandparent gets hit
In Event Capturing/Trickling, if user clicks the child div then first grandparent's onClick event gets hit then parent's then child's

Developer can select which method they want to follow according to the usecase, third argument in the addEventListener method denotes a
boolean value which is useCapture, if we pass true as the third argument then Capturing/Trickling will be followed whereas if we pass false
or we don't pass anything then then Bubbling will be followed.

according to w3c, Capturing/Trickling happens first and then bubbling happens, so if we use mix of the third parameter eg true for some div
and false for some other, so when first capturing will be happening then if that event will have useCapture as true then it will get hit
otherwise it will get hit when after capturing is finished and bubbling will be happening then that useCapture=false event will get hit

but this has a performance issue as if we have multiple sub divs and all/most of the divs has such events then all those will be hit
if we don't want these propogation then we can put the method e.stopPropogation(); inside the event method after which we don't want
propogation to happen where e is the event(parameter which can be set to the callback function).
but if we don't want propogation and we are clicking the child div and we are in capturing mode then we can't stop propogation if we want
our child click event to occur, as in capturing, propogation will be starting from the grandparent and if we stop propogation after 
grandparent then child click event won't hit

IMPORTANT
*Event Delegation: is the method of handling events in a better way, it is based upon event bubbling. It helps in the case when we have too
many same events on divs. It says that instead of attaching event listeners to each and every child div, event listener should be attached
to the parent div. We obviously get the event hit of the parent after it happens in the child in case of bubbling, so we can run main code
on the event hit of the parent. We don't have to add a event to the child, bubbling will still hit event of it's parent.
element parameter of the callback function of the parent event will tell us on which child event occured with the help of event.target.

usecase: if we have multiple tiles of the brands on the ecommerce website and we don't know before hand that which category will have how
many number of brands and anyways even if we know that, still applying events to all the tiles won't be a good option to take, instead of
that we can apply event Listener to it's parent div and in parent div event callback function we can know which brand is selected and then
we can perform the required action for that brand.
Another usecase can be when we want to perform any same action on the form input fields like check validation or make entered values in
uppercase, in that case as well we can do it on the parent div, instead of applying same individual events.
IMPORTANT
pros: memory saved, cleaner/lesser code, DOM manipulation (dynamically multiple events won't be required to add)
cons: all events are not bubbled up like blur, focus, resizing of the window etc, in case of stop propogation event delegation won't work.


*Callback hell: callback inside callback inside another callback or any number of callbacks creates a callback hell. This structure of
something inside something else and so on is known as pyramid of doom.
There is one more issue of callback, Inversion of control which occurs when we pass the control of callback function to another function
eg. passing callback fn to the api call then wait for that api to call that callback function, we loose control of that function and we don't
know whether that callback function will be called or not.


*Promises: are used to handle asynchronous operations without the issues which callback creates. Technically promise is nothing but a empty
object {data: undefined}. Value in it gets filled whenever we get response from an api call, that response will get stored in the promise
object (as promise object will be initialised by that api call) but at the starting of the execution of the code, JS puts up a empty object.

const promiseVariable = createObject(cart); //where api will be called inside createObject function and api response will be returned from it.
cart is just any value which we wish to send to api
We can apply our callback function on the promise object with promiseVariable.then(()=>{//code}); which will be called when promise gets a
response from the api call.

Before promises, if we want to implement asynchronous tasks we used to use callbacks for eg there is one api to createOrder which will return
orderID and then we have another api to proceedToPayment which takes the orderID which createOrder api will return
so with callback, we used to give proceedToPayment function to createOrder api assuming when it will come back with the orderID it will call
our proceedToPayment callback fn, but we don't know the implementation of createOrder api so we don't know whether our proceedToPayment will
be called or not or whether it will be called once or multiple times (basically we don't have control over it, which is the case of inversion
of control)
After promises, our APIs gives us a promise(object initially {data: undefined}) initially but when API returns with a response then it updates
promise object with value passed to data key automatically
To call another function or to use the response returned from the API, we put that function/callback fn/commands in 
promiseReturned.then((data)=>{//code}); 
IMPORTANT
and this steps/callback fn will be called only when API returns the response in promise object.
Promises gives us this garentee that whenever it will get data in promise object then it will call our steps/callback fn once.
IMPORTANT
In reality it's not data key, promise object is much more than that but it's true that at first promiseResult is undefined and when API returns
the response then it will set that promiseResult with that returned response.

There is one more value in promise object which is promiseState which is "Pending" in starting but when it gets response from API then it
becomes "Fulfilled" another state is "Rejected"


*Promise object can't be mutated(changed) which makes our api response safe.


*We say promise is resolved when we get response from the API into the promise object.


*To define Promise we can say that promise is an object representing future value of aynchronous task or API call.


*to delete any key-value pair from an object:
delete objName.keyName;
If the property which you are trying to delete does not exist, delete will not have any effect and will return true.
delete ONLY has an effect on own properties. If a property with the same name exists on the object's prototype chain, then after deletion, 
the object will use the property from the prototype chain.
Non-configurable properties cannot be removed. This includes properties of built-in objects like Math, Array, Object and properties that are 
created as non-configurable


*'this' acts different inside arrow functions


*Promise Chaining: It is a situation where we have multiple asynchronous taks to perform. Eg. we have one api on success of which we have
to call another api on success of which we have to call another api or perform any other task. If we are implementing promise chaining
then do remember to return the promise object then only we can attach .then for next steps.

Over here we were thinking in terms of fetch api which returns the promise, but if we want to perform some asynchronous tasks then we can
make and return our own promise as well.

To create our own promise,
const pr = new Promise(function(resolve, reject){
	//logic
	//eg. validate cart then create order then get order id
	//if anything fails then we reject this promise
	//eg.
	const err = new Error("Cart is not valid");
	reject(err); //here that reject funcion comes into picture
	//if nothing fails, then we resolve the promise
	//eg.
	resolve(orderID);
});
where resolve and reject are functions which are given by JS to build promises.
return pr; //whoever will use this promise will either get orderID or err as a response of the promise


*In case of promise fulfillment, we can get the response in promise.then((response)=>{//access response});
but in the case of promise rejection, we will have to attach .catch like below
promise.then(//all code).catch((err)=>{//handle error by getting error with err.message});
if we will not handle/catch the error then it will give red color error in browser's console.

*In case of promise chaining, we apply .catch at the very end of the chain and whichever promise will return an error then it will get catched
to our catch block and chain will break after that promise.then block.

But if we don't want our chain to break, then we can apply .catch block in between of the chain as well. Wherever we will apply .catch method
it will handle the error of the upper promise block/blocks. In that case even if error comes, it will process with the promise block/blocks
ahead of it.
eg.
promise.then(//callback fn)
.then(//callback fn)
.catch(//handle error for first and second .then block)
.then(//callback fn)
.catch(//handle error for 3rd .then block);


*If we want to restrict user to add any new key-value pair into the object:
Object.seal(objName);
but we can update the values of the existing keys
it won't give error if we try to add any other key-value pair, it will just not add it to the object