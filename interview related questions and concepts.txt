*If we want to increase the value of each element of an array by 2 and we are using forEach loop to do so

arr.forEach((ar, index) => {
	ar = ar+2; //this won't do the needfull as 'ar' is like a temp variable which is just holding the array element one by one, therefore only
	//the value of temporary(ar) variable is getting increased
	arr[index] = ar+2;
	arr[index] = arr[index] + 2; //both the above one and this statement will do the work as this will update the array element
});


*let flattenedArr = [].concat(...arr); this will flaten the array 'arr' to one level
if we want to do it without concat function then we can do one level by simple forEach loop as well as follows:
let flattenedArr = [];
arr.forEach((ar)=>{
    flattenedArr.push(...ar);
});

*to flaten the array to multiple level we have a predefined method .flat
let flattenedArr = arr.flat(2); //if we want to flat the array 'arr' to two level

Custom flat method can be written in two ways, one with use of .concat and another without that, both of the methods you can see below

const customFlatFunction1 = (arr, depth) => {
    let resultArr = arr;
    for(let i=0; i<depth; i++){
        const tempArr = [];
        resultArr.forEach((ar, index)=>{
            if(typeof ar === "object")
                tempArr.push(...ar);
            else
                tempArr.push(ar);
        });
        resultArr = tempArr;
    }
    return resultArr;
}

//with .concat
const customFlatFunction2 = (arr, depth) => {
    let resultArr = arr;
    for(let i=0; i<depth; i++){
        resultArr = [].concat(...resultArr);
    }
    return resultArr;
}


*output question
for(var i=0; i<3; i++){
	setTimeout(function log(){
		console.log(i);
	}, i*1000);
}

output:
3
3
3

//why, bcz var is function scoped so everytime callback will store reference to the variable, so after the loop is finished and callback fn
comes back to the callstack then it will point to the current value of 'i' which is 3


In case of i being declared with 'let', let being block scope, it will send its scope with the callback function, which will then print
0
1
2


*Interviewer might ask you to print different values of i while variable being 'var' itself
we can do that with the help of closures

    for(var i=0; i<5; i++){
        function closure(i){
            setTimeout(()=>{console.log(i)}, 1000);
        }
        closure(i);
    }


*Function composition is an approach where the result of one function is passed on to the next function, which is passed to 
another until the final function is executed for the final result.
compose function is a predefined function in some libraries which returns a function which we can use to perform multiple action at once
function addFive(a){
	return a+5;
}
function subtractTwo(a){
	return a-2;
}
function multiplyFour(a){
	return a*4;
}
const evaluate = compose(addFive, subtractTwo, multiplyFour); //evaluate will contain the function returned from compose fn
console.log(evaluate(5)); //23

what compose does is, when we pass parameter in it's returned function then first it will send that parameter to the last parameter
function (5 will go to multiplyFour) then result of that function is then passed to the next function (20 will go to subtractTwo)
similarly result keeps on going left and at last result is finally returned


*Pollyfill of compose function
function compose(...arguments){
	return (value)=>{
		let args = [...arguments];
		for(var i=args.length-1; i>=0; i--){
			value = args[i](value);
		}
		return value;
	}
}

as compose goes from back to front, there is one more function which is pipe which executes the function from start till end.


*Reverse the words in the provided sentence:
let abc=’My love is Javascript’;
console.log(abc.split(” “).reverse().join(” “))
OUTPUT:Javascript is love My


*Remove first character from the string
let str=”Hello,How are you”;
console.log(str.substring(1,str.length))
OUTPUT:ello,How are you


*Remove the duplicate elements from an array.
const arr = [1, 2, 3, 4, 4, 5,6];
const newArr = […new Set(arr)];
console.log(newArr);
OUTPUT:[1,2,3,4,5,6]


*How to prevent new properties from being added to an object
Object.seal(objName);


*Remove the duplicacy of the objects in an array
const arr=[{id:1,name:’one’},
{id:2,name:’two’},
{id:1,name:’one’},
{id:2,name:’two’},
{id:3,name:’three’}];
const map = {};
const newArray = [];
arr.forEach(el => {
if(!map[JSON.stringify(el)]){
map[JSON.stringify(el)] = true;
newArray.push(el);
}
});
console.log(newArray);
OUTPUT:[ { id: 1, name: ‘one’ },
{ id: 2, name: ‘two’ },
{ id: 3, name: ‘three’ } ]


*Question: How would you implement a function which if called like this sum(1)(2)(3)(4)....() returns me the sum of all the numbers passed?

Solution: let sum = function(a){
						return function(b){
									if(b){
										return sum(a+b);
									}
									return a;
								}
					}
this is a recursive function which will terminate when no argument will be passed.


*Output question
let data = {name: "Prateek"};
console.log(delete data.name); //true
//if any property doesn't exist, delete will still return true, doing no effect on the object
//it will only return false if we try to delete which can't be deleted, eg the object itself, to know more refer delete in JS notes


*Explain call, apply & bind methods and implement their polyfills
these are methods used for object sharing, if there is one method which we want to share between objects then we can apply these methods on
that method(which will be using this.property to use the attached object property)

methodName.call(obj, argument1, argument2); 
call takes obj as first argument and after that n number of arguments which that method require, it executes the method

methodName.apply(obj, [argument1, argument2]);
apply takes obj as first argument but it takes array of arguments which will be passed to that function seperately, it also executes the method

const anotherMethodName = methodName.bind(obj, argument1);
anotherMethodName();
bind takes obj as first argument and takes n number of arguments which that function needs, it doesn't execute the method instead it just returns
the method assigning that object with that method, which we can call later.

Their Polyfills:

const person1 = {
    name: "Prateek",
    printName: function (age, city) {
        console.log(`${this.name} is ${age} years old from ${city}.`);
    }
}

const person2 = {
    name: "Aman"
}

//Polyfill of .call fn
//we add our custom fn to Function.prototype so that any fn can call our method
Function.prototype.myCall = function(obj, ...args){
    console.log(this); //this will print printName function of person1
    obj.fn = this; //here we are adding person1 function printName to person2 obj for this function's scope
    obj.fn(...args); //here we are passing the arguments as they must be passed to myCall method
}

person1.printName.call(person2,25); //Aman is 25 years old
person1.printName.myCall(person2, 26); //Aman is 26 years old
person2.fn(27); //Aman is 27 years old
//bcz now myCall has added printName fn of person1 to person2 obj

//Polyfill of .apply fn
Function.prototype.myApply = function(obj, args){
    //here in the parameters we have not used spread operator as we are already getting array of arguments
    obj.myFn = this;
    obj.myFn(...args);
}

person1.printName.apply(person2, [28]); //Aman is 28 years old
person1.printName.myApply(person2, [29]); 

//Polyfill of .bind fn
Function.prototype.myBind = function(obj, ...args){
    obj.myFn = this;
    return function (){
        obj.myFn(...args);
    }
}

person1.printName.bind(person2, 30)();//we are again calling the fn as .bind doesn't execute the method, it just
//returns the method by making it ready for passed obj

person1.printName.myBind(person2, 31, "Pilibhit")();


*OUTPUT
let data = {
    name: "Prateek",
    age: 24
};

let info = {
    city: "Pilibhit"
};

data = {data, ...info};
console.log(data); // {data: {name: "Prateek", age: 24}, city: "Pilibhit"}


*OUTPUT
const name = "Prateek";
console.log(name());//will give TypeError mentioning that name is not a function


*OUTPUT
let data = false || {} || null;
console.log(data); //{} 

data = false || 0 || null;
console.log(data); //null

data = false || "Prateek" || {};
console.log(data); //Prateek

above expression will return the first true value ({} or [] or 2 or "str") which it will find, if it doesn't find any true value then it will
return the last false value
just opposite is seen in case of &&, it will return the last true value in case all values are true, first false value which it will find


*OUTPUT
console.log(Promise.resolve(5)); //Promise{<fulfilled>: 5}


*OUTPUT
console.log(`${(x => x)('I Love')} to program.`);


*OUTPUT
console.log(!typeof "hello" === 'object'); //false
console.log(!typeof "hello" === 'string'); //false bcz first ! will operate then ===


*OUTPUT
let data = ["a", "b", "c"];
delete data[1];
console.log(data); //['a', empty, 'c'];
console.log(data[1]); //undefined
console.log(data.length); //3


*OUTPUT
let a = 4;
setTimeout(()=>{
	console.log(a);
}, 0);
a = 100;
output: 100 //as setTimeout will run after our whole JS code is executed, even if we had any value in setTimeout, it will still print 100


*OUTPUT
let a = 10;
let A = 20;
console.log(A); //20
console.log(a); //10 as java is case sensitive, both variables are different


*How to know the OS name in JS
navigator.platform
it will return Win32 in case of windows


*Explaination of very famous question of scope of var & let with for loop
as var creates a global variable so our variable of callback fn will point to that global variable in it's lexical scope
whereas let is blocked scope, so for every block of for loop there will be different let variable in lexical scope of every callback fn


*var x;
var x = 10;//this is fine

var x;
let x = 10;//this will give error as 'x' is already defined


*OUTPUT
const y = 3;
const x = new Number(3);
console.log(typeof y); //number
console.log(typeof x); //object 


*OUTPUT
const sum = eval('10*10+5');
console.log(sum);//105
eval converts string passed into it as an expression and executes


*OUTPUT
const obj = {1: 'a', 2: 'b', 3: 'c'};
console.log(obj.hasOwnProperty('1'); //true
console.log(obj.hasOwnProperty(1); //true 
we can keep number as a key and we can access it's value either by same string value or numberic


*by default useCapture(third argument in event handler) is false, if not then capturing happens first and then bubbling happens.


*OUTPUT
function sum(){
    return (()=>0)();
}
console.log(sum()); //0


*OUTPUT
function sum(){
    return ()=>0;
}
console.log(sum()); //()=>0
console.log(typeof sum()); //function


*OUTPUT
console.log(typeof typeof 1);//string


*OUTPUT
const nums = [1, 2];
nums[5] = 7;
console.log(nums); //[1, 2, empty, empty, empty, 7]
console.log(nums[3]); //undefined


*OUTPUT
const nums = [1, 2];
nums[3] = nums;
console.log(nums); //[1, 2, empty, [1, 2, empty, [1, 2, empty, ......infinity]]]


*setInterval returns a unique id, with the help of which we can stop that setInterval
setInterval helps us to perform some step after a particular time interval


*Promise.race([promiseOne, promiseTwo]).then(res => console.log(res));
this will print the response of the promise which will return it's response faster


*OUTPUT
const obj = {name: 'Prateek', age: 24};
for(const item in obj){
	console.log(item);
}
output: 
name
age

item will contain key


*OUTPUT
let data = [1, 2, 3].map(num => {
	if(typeof num === 'number')
		return;
	};
console.log(data); [undefined, undefined, undefined]
if we don't return anything then it returns undefined


*OUTPUT
function car(){
	this.brand = 'KIA';
	return {brand: 'Audi'};
}
const myCar = new car();
console.log(myCar.brand); //Audi


*OUTPUT
function car(){
	this.brand = 'KIA';
}
const yourCar = new car();
console.log(yourCar.brand); //KIA


*OUTPUT
console.log(typeof x); //undefined


*OUTPUT
(()=>{
    let x = y = 10;
})();
console.log(y); //10 as y gets defined as 'var' as we have not mentioned anything before that
console.log(x); //error as x is defined with let and let is block scoped
console.log(typeof x); //undefined, as type of not declared or not initialized variable is undefined


*OUTPUT
let x = 100;
(() => {
	var x = 20;
})();
console.log(x); //100


*OUTPUT
console.log(!true - true); //-1
console.log(true + +'10'); //11


*str.replace(' ', '_'); //this will return an array replacing first blank space with _ in str string, it will not update str string itself
str.replaceAll(' ', '_'); //this will replace ALL the black spaces with _


*str.substring(1, 10); //will return the string containing characters from index position 1 till 9(including) of str string


*to reverse a string in short
str.split("").reverse().join(""); //this will first convert the string to array with individual characters from the string and will
then reverse that array and will then join the reversed characters of array to convert it into string
bcz we cannot directly reverse string, but we can do in case of array


*str.trimEnd(), str.trimStart() can be used to trim spaces from starting and ending of the string

*typeof any function is function


*name in Window object is empty string, so if we will access any random variable with this keyword in global scope then it will
return undefined but in the case of this.name where this is pointing to Window object then it will print nothing(empty string)


*Implement memoization/caching
we use memoization/caching when we want to store some value for future use to optimize UX

function myMemoization(fn, context){
    const result = {}; //this will store result of the heavyFunction according to parameters passed to that function
    return function(...args){
        const tempKey = JSON.stringify(args); //this will convert passed parameters into string, so that for same parameters, key can be same
        if(!result.hasOwnProperty(tempKey)){
            result[tempKey] = fn.call(context || this, ...args); //this will set the result of the heavyFunction for a particular parameters if not already present 
        }
        return result[tempKey];
    }
}

const performHeavyAction = (num1, num2) => {
    for(let i=0; i<10000000; i++){
        //heavy task
    }
    return num1*num2;
}

const memoizedPerformHeavyAction = myMemoization(performHeavyAction);

console.time("heavy-action");
console.log(memoizedPerformHeavyAction(23, 2));
console.timeEnd("heavy-action"); //this will just console the time taken to perform that function call

console.time("same-heavy-action");
console.log(memoizedPerformHeavyAction(23, 2));
console.timeEnd("same-heavy-action");


*Infinite Currying
function sum(a){
    return function(b){
        if(b){
            return sum(a+b);
        }
        return a;
    }
}

console.log(sum(2)(3)(6)(1)());


*Implement
const result = calc.add(10).multiply(3).subtract(10).add(1);
console.log(result.total);

ans:
const calc = {
    total: 0,
    add: function(value){
        this.total += value;
        return this;
    },
    multiply: function(value){
        this.total *= value;
        return this;
    },
    subtract: function(value){
        this.total -= value;
        return this;
    }
}


*Implement folder structure in react from json object
folderStructure.js
	export default {
	  name: "root",
	  isFolder: true,
	  items: [
		{
		  name: "public",
		  isFolder: true,
		  items: [
			{
			  name: "index.html",
			  isFolder: false
			}
		  ]
		},
		{
		  name: "src",
		  isFolder: true,
		  items: [
			{
			  name: "assets",
			  isFolder: true,
			  items: [
				{
				  name: "folderStructure.js",
				  isFolder: false
				}
			  ]
			},
			{
			  name: "components",
			  isFolder: true,
			  items: [
				{
				  name: "Folder.js",
				  isFolder: false
				}
			  ]
			},
			{
			  name: "App.js",
			  isFolder: false
			},
			{
			  name: "index.js",
			  isFolder: false
			},
			{
			  name: "styles.css",
			  isFolder: false
			}
		  ]
		},
		{
		  name: "package.json",
		  isFolder: false
		}
	  ]
	};
	
Folder.js
	import { useState } from "react";

	function Folder(props) {
	  const [openStr, setOpenStr] = useState(false);
	  const name = props.data.name;
	  function openFolderHandler() {
		if (props.data.isFolder) setOpenStr((prevState) => !prevState);
	  }
	  return (
		<div>
		  <p onClick={openFolderHandler}>{name}</p>
		  {openStr && (
			<div style={{ paddingLeft: "20px" }}>
			  {props.data.items.map((item, index) => (
				<Folder key={index} data={item} />
			  ))}
			</div>
		  )}
		</div>
	  );
	}

	export default Folder;

App.js
	import "./styles.css";
	import Folder from "./components/Folder";
	import folderStructure from "./assets/folderStructure";

	export default function App() {
	  return (
		<div className="App">
		  <Folder data={folderStructure} />
		</div>
	  );
	}



*features of react
*var x = 10;
let x = 100; //will throw error, we can define global variables again and again but can't define them in seperate area(where let & const reside) again


*delete keyword is used to delete just the object properties, it doesn't delete local variables (it won't do any effect no error nothing)
OUTPUT
const func = (function(a){
		delete a;
		return a;
		})(5);
console.log(func);//5


*OUTPUT
const a = {};
const b = { key: 'b' };
const c = { key: 'c' };

a[b] = 10; //this will internally as a["[object Object]"] = 10; as js converts b into string with .toString() and then stores value against that
a[c] = 20;
console.log(a[b]); //20


*OUTPUT
const obj = {
	key1: 'a',
	key2: 'b',
	key3: 'c'
};
const data = JSON.stringify(obj, ['key2', 'key3']); //it will only stringify the passed keys as a second argument in array
//if we pass any unidentified key then it will just ignore that new key and if we will not pass keys in array then it will ignore the second 
//parameter and will just stringify whole object
console.log(data); //{'key2': 'b', 'key3': 'c'} 


*'this' keyword inside object points to the window object whereas 'this' keyword inside normal function points to the object


*Shallow copy is when we just copy the reference, so if we change anything in new object/array then original object/array also gets changed
whereas in deep copy whole same new object/array in created in the memory


*Que. What is HTML5? What are some of its new features that were not present in HTML?
Ans. HTML5 is the latest version of the Hypertext Markup Language. Some of the new features of HTML5 are:

It has multimedia support.
It has the capabilities to store offline data using SQL databases and cache.
JS can be run in background.
It also allows users to draw various shapes like circle, rectangle etc.
Includes new semantic tags and form control tags.


*New input types in HTML5 for forms: date, datetime, datetime-local, month, time, week, email, number, url


*Ways to optimise website asset loading time: CDN Hosting, File compression, File concatenation, minify scripts, parallel downloads, lazy loading.


*Local Storage: 10 mb, HTML 5 accessible, any window/tab, never expire, only strings supported, no auto expiration, browser is the storage location
			   not sent with requests, editable or blockable by users.
			   
Cookie Storage: 4 kb, HTML 4 & 5 accessible, any window/tab, expiration manually set and till browser is open, only strings supported, browser and 
			    server is the storage location, sent with requests, editable or blockable by users, auto expiration option avaiable
				
Session Storage: 5 mb, HTML 5 accessible, same tab accessible, expiration on tab close, auto expiration option avaiable, only strings supported, 
				 browser is the storage location, not sent with requests, editable or blockable by users.


*An image map is defined by the <map> tag. Using this the image map tag, we can linking the different web pages using a single image. We can
 add one or more clickable areas in a single image using <area> tags.
 
 
*
Que. What is URL Encoding? Why are URLs encoded in HTML?
Ans. URL Encoding is the process of encoding non-ASCII characters in URLs to a format that is universally accepted by web browsers. URLs are 
sent over the Internet using the ASCII character set. If a URL contains characters outside the ASCII set, the URL has to be converted. 
URL is encoded in HTML as it converts non-ASCII characters into a format that can be transmitted over the web. The URL encoding replaces 
non-ASCII characters with a “%” followed by hexadecimal digits.


*The <figure> tag identifies self-contained content related to the main content.
<figure>
    <img src=”pancakes.jpg” alt=”Blueberry Pancakes”>
    <figcaption>A Stack of Blueberry Pancakes</figcaption>
</figure>

*The <datalist> tag provides autocomplete feature in the HTML files.
<label for=”car”>Choose your car from the list:</label>
<input list=”cars” name=”car” id=”car”>
<datalist id=”cars”>
  <option value=”Honda”>
  <option value=”Hyundai”>
  <option value=”Maruti”>
  <option value=”Audi”>
  <option value=”BMW”>
</datalist>


*Inline CSS has the highest priority, then comes Internal/Embedded followed by External CSS which has the least priority.


*Inline-block: This feature uses both properties: block and inline. So, this property aligns the div inline but the difference is it can edit 
the height and the width of the block. Basically, this will align the div both in the block and inline fashion.


*Features/advantages of react
It is based on components with the help of which we can achieve seperation of concern.
It increases the application's performance with the help of virtual dom.
It can be used on client and server side as well. Server side with the help of it's framework Next.js
Because of JSX code readibility increases.


*Disadvantages of react:
It is just a library not a full blown framework like angular which has more features.
It can become difficult to understand bcz of inline templates(JSX)


*Can browser read JSX directly?
No, browser can only read JS object and JSX is not a JS object. Therefore react converts JSX into JS object internally and then gives it to
browser.


*What is state in react?
State is an object which contains data about the component. Whenever component state changes the component re-renders. We can update state
of the component with the help of useState


*Difference between props & states:
props are read only whereas state can be changes.
props can be accessed by the child component whereas state of the parent component can't be accessed by child component.
Stateless component can have props whereas stateless component cannot have state.


*What are different phases of react component's lifecycle?
Initial rendering phase, updating phase, unmounting phase.
1. componentWillMount()
2. componentDidMount()
3. componentWillReceiveProps()
4. shouldComponentUpdate()
5. componentWillUpdate()
6. componentDidUpdate()
7. componentWillUnmount()


*shallow copy copies the object/array upar upar se, not properly. It copies reference of the object/array to the new variable, therefore when
new variable changes the value in it's object/array then original object/array value will also gets changed.
Whereas in deep copy, object/array values are copied in new memory location and new variable points to that new memory location.


*parameters of map fn: array.map(function(currentValue, index, arr), thisValue) 


*position values:
Static: not affected by tblr(top, below, left, right) properties/values.
Relative: tblr values cause element to move from its normal position.
Absolute: positioned relative to its parent element that is positioned relative.
Fixed: positioned relative to the viewport. Keeps same position even after scrolling.
Sticky: positioned based on scroll position. Position can be set when scrolled like the navbar.


*useCallback is a hook that will return a memoized version of the callback function that only changes if one of the dependencies has changed.


*How do we implement componentdidunmount in functional component
useEffect(() => { 
   document.addEventListener('click', handleClick);

   return function cleanup () {
     document.removeEventListener('click', handleClick);
   }
}, [])
Here we return a cleanup function with the removing logic of our event. As per react hooks rule whenever an effect received a return function 
it runs only at the time of cleanup of the component.


*A React component is considered pure if it renders the same output for the same state and props.


*a higher-order component is a component function that takes a component and returns a new component. With HOC we can share the component logic
within multiple components. If a component (logic) is required in more than one other components then we can pass that component to HOC.


*What is strict mode in react?
It is a functionality provided by react which helps us to write better code by highlighting potential problems in an application.
For it to implement, we can wrap our components or JSX inside <React.StrictModeS>JSX logic/components</React.StrictModeS>
so components inside these will only be covered by strict mode.


*React Hooks are simple JavaScript functions that we can use to isolate the reusable part from a functional component.


*Pangram: is a sentence which contains ALL the alphabets of english from A-Z every character at least once.


*Object manipulation question:
From given JSON array of objects, return array of Menu names used
const apiResponse = [
    {
        name: "Menu 1",
        link: "google.com",
        subItems: [
            {
                name: "Menu 2",
                link: "facebook.com"
            }
        ]
    },
    {
        name: "Menu 3",
        link: "gfg.com",
        subItems: [
            {
                name: "Menu 4",
                link: "maps.com",
                subItems: [
                    {
                        name: "Menu 5",
                        link: "Google.com"
                    },
                    {
                        name: "Menu 6",
                        link: "wiki.org"
                    }
                ]
            }
        ]
    },
    {
        name: "Menu 7",
        link: "twitter.com"
    }
]

function getItemsForObject(resultArr, obj){
    resultArr = [...resultArr, obj.name];
    obj.subItems?.map((item)=>{
        resultArr = [...getItemsForObject(resultArr, item)];//as we don't know how many nested objects can be there that's why recursion
    });
    return resultArr;
}

const resultArr = apiResponse.reduce((resultArrTemp, arrElement)=>{
    resultArrTemp = [ ...getItemsForObject(resultArrTemp, arrElement)];
    return resultArrTemp;
}, []);

console.log(resultArr);// ['Menu 1', 'Menu 2', 'Menu 3', 'Menu 4', 'Menu 5', 'Menu 6', 'Menu 7']


*IIFE: Imedietly invoked function expression
const ans = ((value)=>value*value)(5); //const ans = IIFE
console.log(ans); //25


*Function hoisting

functionName(); //I am called

functionName(){
	console.log("I am called");
}


//in case of function expression
functionName(); //Error: functionName is not a function bcz at this line, functionName = undefined

var functionName = () => {
	console.log("I am called");
}

functionDeclaredWithLetAndConst(); //Error: Cannot access functionDeclaredWithLetAndConst before initialization bcz we can't access let or 
//const variables before their initialization

let functionDeclaredWithLetAndConst = () => {
	console.log("I am called");
}


*arguments
//we don't even have to add parameter for arguments, function declaration/definition will automatically take it in 'arguments' variable
function f(){
	console.log(arguments); //[1, 3, 2]
}

f(1, 3, 2);
//but we can't do the same thing in arrow functions, it will give error as arguments not defined
//we can do it in normal function expression but not in case of arrow functions


*if there is nested objects, so 'this' used inside the nested object will point to that nested object, so if we will access any variable with 
'this' keyword then JS will search for that variable only inside the nested object, not inside outer object.

IMPORTANT
*let user = {
	name: "prateek",
	age: 24,
	getDetails(){
		const nestedArrowFunction = () => { console.log(this.name) };
		nestedArrowFunction();
	}
}
user.getDetails(); //prateek
bcz arrow function initializes this with it's parent this variable, so in above case, parent is getDetails() inside which 'this' points to
object user so arrow function inside getDetails() will also point it's 'this' to object user

In the case of arrow function directly inside an object, it's parent becomes the global scope(if object is declared globally, otherwise the 
scope in which object is declared) as object doesn't forms a scope with it's {} and in global scope this = window object
So when arrow function is directly inside an object then 'this' inside that arrow function points to window object.


*const obj = {
    name: "Prateek",
    getName(){
        const name = "Prateek Agarwal";
        console.log(this.name);
    }
}
obj.getName(); //Prateek

//'this' used inside the normal function will either point to object it is declared in or will point to window object if declared outside object
//even inside nested function, 'this' will point to window object


*OUTPUT
const obj = {
    ref: this
}

console.log(obj.ref); //window object
//therefore only normal function inside an object points to that object, otherwise 'this' everywhere else inside an object will point to window object


*OUTPUT
const obj = {
	firstName: "Prateek",
	getName(){
		console.log(this.firstName);
	}
}
setTimeout(obj.getName, 1000); //undefined

//because, getName will take it's scope and it's lexical scope with it as a closure and as object doesn't form a scope so it will take window
//object as it's lexical scope and firstName is not defined in window object therefore it logged undefined


*whereas
const obj = {
	firstName: "Prateek",
	getName(){
		console.log(this.firstName);
	}
}
setTimeout(function(){
				obj.getName(); //Prateek
			}, 1000);
			
//in this case, function will form a scope and firstName will be inside it therefore getName will point to that scope

*function fun(){
	console.log("callback");
}
setTimeout(fun(), 1000); //callback
setTimeout(fun, 1000); //callback


*If you are asked to take value from the user, you can use prompt
let a = prompt("a= ", 0); //0 will be it's default value


*OUTPUT
var length = 4;
function callback(){
	console.log(this.length);
}

const obj = {
	length: 5,
	method(fn) {
		fn();
	},
	method2(){
		arguments[0]();
	}
}

obj.method(callback); //4 bcz callback fn will be sent with it's lexical scope, it's same as nested functions where nested function points to window object

obj.method2(callback, 2); //2 bcz callback function will be inside an array arguments, in that case this will point to array object and inside
array prototype there is length property which tells the length of the array (which is 2 in this case)


*difference between virtual dom and real dom
A virtual DOM object is a representation of the original DOM object. 
Whenever any modifications happen in the web application, the entire UI is re-rendered in virtual DOM representation. 
Then it checks the difference between the previous DOM representation and new DOM. 
Once it has done, the real DOM will update only the things that have actually changed. 
This makes the application faster, and there is no wastage of memory.
Whereas if we will directly update the real dom, it will re-render whole real dom which will be very expensive for the performance.


*what is babel
babel is a transpiler which translates latest JS code to the version which older browser versions can also understand.

transpiler converts the source code into another source code whereas compiler converts the source code into machine code(which machine can understand)

// sample new version javascript code
const fun = (x) => {x*2};

after transpiling through babel it becomes
var fun = function fun(x) {
  x * 2;
};


*difference between map and forEach
map returns a new array whereas forEach returns undefined(even if we return something explictly), both map and forEach doesn't iterate on empty elements


*difference between null and undefined
null can be assigned to a variable indicating that it doesn't point to any object, we generally don't assign undefined to any variable(though
we can do it), undefined means that a variable has been declared but has not yet been assigned a value.
typeof null is object whereas typeof undefined is undefined (it is a type itself)
null is converted to 0 when performing primitive operations whereas undefined is converted to NAN.
2 + null = 2
2 + undefined = NAN


*What is event loop
JS has a modal based on event loop which takes out tasks from priority queue and callback queue and puts on top of callstack whenever callstack
gets empty, so that callstack can execute those tasks.


*What are ES6 features
2015 version of JS is known as ES6, some of it's features are
let keyword, const keyword, arrow functions, spread operator, rest operator, promises, multiline strings, 
default parameters 
	eg. function func(length = 5, height = 10),
template literals 
	eg. let name = `My name is ${firstName}`;


*Explain hoisting in JS
Hoisting is the process in which it appears that interpreter has moved the variable and function declaration to the top of the scope. 
Whereas normally it is not sent to top of the scope, JS goes through all the code once before executing and in that it declares variables and
functions bcz of which we can use them in the code before it's actual declaration.


*difference between var, let and const
var: function scoped, it can be redeclared and updated, var variable can be used before it's declaration in the same scope(though it's value 
	will be undefined) or we can say that var variable is hoisted
let: block scope, it can't be redeclared but can be updated, let variable can not be used before it's declaration in the same scope, it is also
	hoisted but stay in temporal dead zone until interpreter executes it's declaration/initialization
const: block scope, it can neither be redeclared not be updated, const variable also behaves like let variable in hoisting.

But var variable cannot be redeclared by same let/const variable in same scope.


*explain event delegation
Event delegation is the method of handling events in a better way, it is based upon event bubbling. It helps in the case when we have too
many same events on divs. It says that instead of attaching event listeners to each and every child div, event listener should be attached
to the parent div. We obviously get the event hit of the parent after it happens in the child in case of bubbling, so we can run main code
on the event hit of the parent. We don't have to add a event to the child, bubbling will still hit event of it's parent.

If we take an example of buttons inside a div:
event.target = button element, event.target.tagName = 'BUTTON'
const div = document.querySelector('div')

div.addEventListener("click", (event) => {
  if(event.target.tagName === 'BUTTON') {
    console.log(event.target.innerText)
  }
})


*Polyfill of arr.map
const arr = [1, 2, 3];

//note that here Array.prototype will be used not Function as .map is applied on array (.apply, .call, .bind is applied on functions) and fn
//expression should be a normal function, not arrow function as inside arrow function this will not point to our array
Array.prototype.myMap = function (callback) {
    const arr = [];
    for(let i=0; i<this.length; i++){
        arr.push(callback(this[i], i, this)); //here we should pass all the parameters bcz we don't know how many parameters callback will be using
    }
    return arr;
}

const tripleArr = arr.myMap((element, i, arr)=>{return element*3;});
console.log(tripleArr); //[3, 6, 9]


*Polyfill of arr.filter
const arr = [1, 2, 4, 5, 6];
Array.prototype.myFilter = function(callback) {
    const arr = [];
    for(let i=0; i<this.length; i++){
        if(callback(this[i], i, this)){ //here we should pass all the parameters bcz we don't know how many parameters callback will be using
            arr.push(this[i]);
        }
    }
    return arr;
}

const evenPolyfillArr = arr.myFilter((element)=>{
    if(element%2 == 0){
        return true;
    }
    return false;
});

console.log(evenPolyfillArr); //[2, 4, 6]


*Polyfill for arr.reduce
const arr = [1, 2, 3, 5];

Array.prototype.myReduce = function(callback, initialValue){
    let ans = initialValue === undefined ? this[0] : initialValue; //if user fails to give any initial value then .reduce takes first element of array as the initial value
    for(let i=0; i<this.length; i++){
        ans = callback(ans, this[i], i, this); //here we should pass all the parameters bcz we don't know how many parameters callback will be using
    }
    return ans;
}

const ansPolyfill = arr.myReduce((result, element)=>{
    return result + element;
}, 0);

console.log(ansPolyfill);


*If we wanna filter an array on the bases of some condition, then we should use arr.filter and not arr.map, map can also perform the required
action but the elements which do not satisfy the condition will be filled with undefined in new array whereas in filter, new array will contain
only the elements which satisfy the condition no undefined no empty


*Polyfill of arr.find
let arr = [10, 32, 17, 19];

Array.prototype.myFind = function(cb){
    for(let i=0; i<this.length; i++){
        if(cb(this[i], i, this)){
            return this[i];
        }
    }
}

const greaterThan15 = arr.myFind((element)=>{
    if(element > 15){
        return true;
    }
})

console.log(greaterThan15); //32
arr.find returns first array element which satisfies a particular condition, in implementation we check the condition and return true just like
arr.filter, difference is that instead of array of elements it just returns the first element which satisfies the condition.


*if block creates a block scope. Any let variable defined inside if block, can't be accessed outside it.


*Question
Implement a function which can give below output(in comments)
var addSix = createBase(6);
addSix(10); //16
addSix(21); //27
Answer: 
function createBase(base){
    return function(value){
        console.log(base+value);
    }
}


*Question
Optimise the below implementation with the help of closures
function find(index){
    let a = [];

    for(let i=0; i < 1000000; i++){
        a[i] = i*i;
    }
	console.log(index);
}

console.time("6");
closure(6);
console.timeEnd("6");

console.time("12");
closure(12);
console.timeEnd("12");

Answer:
function find(){
    let a = [];

    for(let i=0; i < 1000000; i++){
        a[i] = i*i;
    }
	
    return function(index){
        console.log(a[index]);
    }
}

const closure = find();
console.time("6");
closure(6);
console.timeEnd("6");

console.time("12");
closure(12);
console.timeEnd("12");


*How will you create a private counter(or any hidden/private variable) using closure
function incrementCounter(){
    let count = 0;
    function incrementCounterBy(value){
        count += value;
    }
    function getCounter(){
        return count;
    }
    return {
        increaseBy: incrementCounterBy,
        value: getCounter
    }
}

const counter = incrementCounter();
counter.increaseBy(6);
counter.increaseBy(3);
console.log(counter.value()); //9


*What is Module Pattern?
var Module = (function(){
				function privateMethod(){
					//code
				}
				
				return {
					publicMethod: function(){
									//code which uses above privateMethod
								}
					}
			})();
Basically module pattern is the pattern of writing a piece of code which is not publically available.


*Question: perform an activity only once
function likeMyVideo(){
    let count = 0;
    return function(){
        if(count == 0){
            count++;
            console.log("Hello");
        }
    }
}

const like = likeMyVideo();
like();//Hello
like();
like();

The above implementation will console the output only once no matter how many times we call that function.


*How is one-way data binding in react different from two way data binding in Angular?
Two-way data binding provides the ability to take the value of a property and display it on the view while also having an input to automatically 
update the value in the model.
In contrast, one way binding only binds the value of the model to the view and does not have an additional watcher to determine if the value 
in the view has been changed by the user. We have to use events like onChange, onBlur to know the latest value.


*Debouncing with arguments
function debouncing(fn, ...args){
    let timer;
    return function(val){
        clearTimeout(timer);
        timer = setTimeout(()=>{fn(val, args)}, 500);
    }
}

function apiCallFor(value, args){
    console.log("API hit for", value);
    console.log(args);
}

const efficientApiCallFor = debouncing(apiCallFor, "arg1", "arg2");

const doc = document.getElementById('text').addEventListener("keyup", ()=>{efficientApiCallFor(event.target.value)});


*OUTPUT
const fruits = "Banana";
const keys = Object.keys(fruits); //0,1,2,3,4,5

const fruits = ["Banana", "Orange", "Apple", "Mango"];
const keys = Object.keys(fruits); //0, 1, 2, 3


*IMPORTANT
const person = {name: "prateek", marks: 100};

Object.defineProperty(person, 'age', {value: 24});
person['country'] = 'India';
console.log(person); // [name: 'prateek', marks: 100, country: 'India', age: 24]
console.log(Object.keys(person)); // ['name', 'marks', 'country']
console.log(person['age']); // 24


*const str = "Hello How are you?";
output should be: Hello Prateek How are you?
ans: const ans = str.replace(/Hello/, 'Hello Prateek');
console.log(ans); //Hello Prateek How are you?


*Difference btw JS Object and Map
Object is not directly iterable, it doesn't have size property, keys must be string whereas in Map key can be any datatype, in Ojbect keys are
not well ordered


*Difference between css and css3
css is slow, with css we can't use styling like border-radius, with css3 we can use gradiant colors, css3 supports RGBA with which we can create
any color. With css3 we can apply animations, text-shadow, Responsive design was not supported in CSS.


*ECMAScript is a JavaScript standard intended to ensure the interoperability of web pages across different browsers. Like at least this much
standard of JS every browser should support.


*Redux Middleware allows you to intercept every action sent to the reducer so you can make changes to the action or cancel the action. 
Middleware helps you with logging, error reporting.


*function callme(...args){
    console.log("I was called with", args);
}

setInterval(callme, 1000, "param1", "param2", "param3"); // I was called with ["param1", "param2", "param3"]


*Polyfill of arr.slice (it returns new array from first parameter to second parameter -1
Array.prototype.mySlice = function(startIndex, endIndex){
    const tempArr = [];
    startIndex = (startIndex === undefined) ? 0 : (startIndex < 0) ? this.length + startIndex : startIndex;
    startIndex = (startIndex < 0) ? 0 : startIndex; //in the case when startIndex is -(more than length of array)
    endIndex = (endIndex === undefined || endIndex > this.length) ? this.length : (endIndex < 0) ? this.length + endIndex : endIndex;
    for(let i = startIndex; i<endIndex && i<this.length; i++){
        tempArr.push(this[i]);
    }
    return tempArr;
}

*GET api call
 React.useEffect(async ()=>{
    const res = await fetch(url);
    const data = await res.json();
    setUserData(data);
  }, []);
  
  

*Implement promise.all
*Implement throttling
*project showcase and questions on it
*Implement https://medium.com/geekculture/react-coding-interview-task-c9f21fb872e2 after revising context.
*(advanced)What Is Redux Middleware? https://www.freecodecamp.org/news/what-is-redux-middleware-and-how-to-create-one-from-scratch/
*for more CSS interview questions: https://www.geeksforgeeks.org/css-interview-questions-and-answers/
you have read till 32
For more CSS interview questions: https://www.naukri.com/learning/articles/css-interview-questions-and-answers/