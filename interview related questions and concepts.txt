*If we want to increase the value of each element of an array by 2 and we are using forEach loop to do so

arr.forEach((ar, index) => {
	ar = ar+2; //this won't do the needfull as 'ar' is like a temp variable which is just holding the array element one by one, therefore only
	//the value of temporary(ar) variable is getting increased
	arr[index] = ar+2;
	arr[index] = arr[index] + 2; //both the above one and this statement will do the work as this will update the array element
});


*let flattenedArr = [].concat(...arr); this will flaten the array 'arr' to one level
if we want to do it without concat function then we can do one level by simple forEach loop as well as follows:
let flattenedArr = [];
arr.forEach((ar)=>{
    flattenedArr.push(...ar);
});

*to flaten the array to multiple level we have a predefined method .flat
let flattenedArr = arr.flat(2); //if we want to flat the array 'arr' to two level

Custom flat method can be written in two ways, one with use of .concat and another without that, both of the methods you can see below

const customFlatFunction1 = (arr, depth) => {
    let resultArr = arr;
    for(let i=0; i<depth; i++){
        const tempArr = [];
        resultArr.forEach((ar, index)=>{
            if(typeof ar === "object")
                tempArr.push(...ar);
            else
                tempArr.push(ar);
        });
        resultArr = tempArr;
    }
    return resultArr;
}

//with .concat
const customFlatFunction2 = (arr, depth) => {
    let resultArr = arr;
    for(let i=0; i<depth; i++){
        resultArr = [].concat(...resultArr);
    }
    return resultArr;
}


*output question
for(var i=0; i<3; i++){
	setTimeout(function log(){
		console.log(i);
	}, i*1000);
}

output:
3
3
3

//why, bcz var is function scoped so everytime callback will store reference to the variable, so after the loop is finished and callback fn
comes back to the callstack then it will point to the current value of 'i' which is 3


In case of i being declared with 'let', let being block scope, it will send its scope with the callback function, which will then print
0
1
2


*Function composition is an approach where the result of one function is passed on to the next function, which is passed to 
another until the final function is executed for the final result.
compose function is a predefined function in some libraries which returns a function which we can use to perform multiple action at once
function addFive(a){
	return a+5;
}
function subtractTwo(a){
	return a-2;
}
function multiplyFour(a){
	return a*4;
}
const evaluate = compose(addFive, subtractTwo, multiplyFour); //evaluate will contain the function returned from compose fn
console.log(evaluate(5)); //23

what compose does is, when we pass parameter in it's returned function then first it will send that parameter to the last parameter
function (5 will go to multiplyFour) then result of that function is then passed to the next function (20 will go to subtractTwo)
similarly result keeps on going left and at last result is finally returned


*Pollyfill of compose function
function compose(...arguments){
	return (value)=>{
		let args = [...arguments];
		for(var i=args.length-1; i>=0; i--){
			value = args[i](value);
		}
		return value;
	}
}

as compose goes from back to front, there is one more function which is pipe which executes the function from start till end.


*Reverse the words in the provided sentence:
let abc=’My love is Javascript’;
console.log(abc.split(” “).reverse().join(” “))
OUTPUT:Javascript is love My


*Remove first character from the string
let str=”Hello,How are you”;
console.log(str.substring(1,str.length))
OUTPUT:ello,How are you


*Remove the duplicate elements from an array.
const arr = [1, 2, 3, 4, 4, 5,6];
const newArr = […new Set(arr)];
console.log(newArr);
OUTPUT:[1,2,3,4,5,6]


*How to prevent new properties from being added to an object
Object.seal(objName);


*Remove the duplicacy of the objects in an array
const arr=[{id:1,name:’one’},
{id:2,name:’two’},
{id:1,name:’one’},
{id:2,name:’two’},
{id:3,name:’three’}];
const map = {};
const newArray = [];
arr.forEach(el => {
if(!map[JSON.stringify(el)]){
map[JSON.stringify(el)] = true;
newArray.push(el);
}
});
console.log(newArray);
OUTPUT:[ { id: 1, name: ‘one’ },
{ id: 2, name: ‘two’ },
{ id: 3, name: ‘three’ } ]


*Question: How would you implement a function which if called like this sum(1)(2)(3)(4)....() returns me the sum of all the numbers passed?

Solution: let sum = function(a){
						return function(b){
									if(b){
										return sum(a+b);
									}
									return a;
								}
					}
this is a recursive function which will terminate when no argument will be passed.


*Output question
let data = {name: "Prateek"};
console.log(delete data.name); //true
//if any property doesn't exist, delete will still return true, doing no effect on the object
//it will only return false if we try to delete which can't be deleted, eg the object itself, to know more refer delete in JS notes


*Explain call, apply & bind methods and implement their polyfills
these are methods used for object sharing, if there is one method which we want to share between objects then we can apply these methods on
that method(which will be using this.property to use the attached object property)

methodName.call(obj, argument1, argument2); 
call takes obj as first argument and after that n number of arguments which that method require, it executes the method

methodName.apply(obj, [argument1, argument2]);
apply takes obj as first argument but it takes array of arguments which will be passed to that function seperately, it also executes the method

const anotherMethodName = methodName.bind(obj, argument1);
anotherMethodName();
bind takes obj as first argument and takes n number of arguments which that function needs, it doesn't execute the method instead it just returns
the method assigning that object with that method, which we can call later.

Their Polyfills:

const person1 = {
    name: "Prateek",
    printName: function (age, city) {
        console.log(`${this.name} is ${age} years old from ${city}.`);
    }
}

const person2 = {
    name: "Aman"
}

//Polyfill of .call fn
//we add our custom fn to Function.prototype so that any fn can call our method
Function.prototype.myCall = function(obj, ...args){
    console.log(this); //this will print printName function of person1
    obj.fn = this; //here we are adding person1 function printName to person2 obj for this function's scope
    obj.fn(...args); //here we are passing the arguments as they must be passed to myCall method
}

person1.printName.call(person2,25); //Aman is 25 years old
person1.printName.myCall(person2, 26); //Aman is 26 years old
person2.fn(27); //Aman is 27 years old
//bcz now myCall has added printName fn of person1 to person2 obj

//Polyfill of .apply fn
Function.prototype.myApply = function(obj, args){
    //here in the parameters we have not used spread operator as we are already getting array of arguments
    obj.myFn = this;
    obj.myFn(...args);
}

person1.printName.apply(person2, [28]); //Aman is 28 years old
person1.printName.myApply(person2, [29]); 

//Polyfill of .bind fn
Function.prototype.myBind = function(obj, ...args){
    obj.myFn = this;
    return function (){
        obj.myFn(...args);
    }
}

person1.printName.bind(person2, 30)();//we are again calling the fn as .bind doesn't execute the method, it just
//returns the method by making it ready for passed obj

person1.printName.myBind(person2, 31, "Pilibhit")();


*OUTPUT
let data = {
    name: "Prateek",
    age: 24
};

let info = {
    city: "Pilibhit"
};

data = {data, ...info};
console.log(data); // {data: {name: "Prateek", age: 24}, city: "Pilibhit"}


*OUTPUT
const name = "Prateek";
console.log(name());//will give TypeError mentioning that name is not a function


*OUTPUT
let data = false || {} || null;
console.log(data); //{} 

data = false || 0 || null;
console.log(data); //null

data = false || "Prateek" || {};
console.log(data); //Prateek

above expression will return the first true value ({} or [] or 2 or "str") which it will find, if it doesn't find any true value then it will
return the last false value
just opposite is seen in case of &&, it will return the last true value in case all values are true, first false value which it will find


*OUTPUT
console.log(Promise.resolve(5)); //Promise{<fulfilled>: 5}


*OUTPUT
console.log(`${(x => x)('I Love')} to program.`);


*OUTPUT
console.log(!typeof "hello" === 'object'); //false
console.log(!typeof "hello" === 'string'); //false bcz first ! will operate then ===


*OUTPUT
let data = ["a", "b", "c"];
delete data[1];
console.log(data); //['a', empty, 'c'];
console.log(data[1]); //undefined
console.log(data.length); //3


*OUTPUT
let a = 4;
setTimeout(()=>{
	console.log(a);
}, 0);
a = 100;
output: 100 //as setTimeout will run after our whole JS code is executed, even if we had any value in setTimeout, it will still print 100


*OUTPUT
let a = 10;
let A = 20;
console.log(A); //20
console.log(a); //10 as java is case sensitive, both variables are different


*How to know the OS name in JS
navigator.platform
it will return Win32 in case of windows


*Explaination of very famous question of scope of var & let with for loop
as var creates a global variable so our variable of callback fn will point to that global variable in it's lexical scope
whereas let is blocked scope, so for every block of for loop there will be different let variable in lexical scope of every callback fn


*var x;
var x = 10;//this is fine

var x;
let x = 10;//this will give error as 'x' is already defined


*OUTPUT
const y = 3;
const x = new Number(3);
console.log(typeof y); //number
console.log(typeof x); //object 


*OUTPUT
const sum = eval('10*10+5');
console.log(sum);//105
eval converts string passed into it as an expression and executes


*OUTPUT
const obj = {1: 'a', 2: 'b', 3: 'c'};
console.log(obj.hasOwnProperty('1'); //true
console.log(obj.hasOwnProperty(1); //true 
we can keep number as a key and we can access it's value either by same string value or numberic


*by default useCapture(third argument in event handler) is false, if not then capturing happens first and then bubbling happens.


*OUTPUT
function sum(){
    return (()=>0)();
}
console.log(sum()); //0


*OUTPUT
function sum(){
    return ()=>0;
}
console.log(sum()); //()=>0
console.log(typeof sum()); //function


*OUTPUT
console.log(typeof typeof 1);//string


*OUTPUT
const nums = [1, 2];
nums[5] = 7;
console.log(nums); //[1, 2, empty, empty, empty, 7]
console.log(nums[3]); //undefined


*OUTPUT
const nums = [1, 2];
nums[3] = nums;
console.log(nums); //[1, 2, empty, [1, 2, empty, [1, 2, empty, ......infinity]]]


*setInterval returns a unique id, with the help of which we can stop that setInterval
setInterval helps us to perform some step after a particular time interval


*Promise.race([promiseOne, promiseTwo]).then(res => console.log(res));
this will print the response of the promise which will return it's response faster


*OUTPUT
const obj = {name: 'Prateek', age: 24};
for(const item in obj){
	console.log(item);
}
output: 
name
age

item will contain key


*OUTPUT
let data = [1, 2, 3].map(num => {
	if(typeof num === 'number')
		return;
	};
console.log(data); [undefined, undefined, undefined]
if we don't return anything then it returns undefined


*OUTPUT
function car(){
	this.brand = 'KIA';
	return {brand: 'Audi'};
}
const myCar = new car();
console.log(myCar.brand); //Audi


*OUTPUT
function car(){
	this.brand = 'KIA';
}
const yourCar = new car();
console.log(yourCar.brand); //KIA


*OUTPUT
console.log(typeof x); //undefined


*OUTPUT
(()=>{
    let x = y = 10;
})();
console.log(y); //10 as y gets defined as 'var' as we have not mentioned anything before that
console.log(x); //error as x is defined with let and let is block scoped
console.log(typeof x); //undefined, as type of not declared or not initialized variable is undefined


*OUTPUT
let x = 100;
(() => {
	var x = 20;
})();
console.log(x); //100


*OUTPUT
console.log(!true - true); //-1
console.log(true + +'10'); //11


*str.replace(' ', '_'); //this will return an array replacing first blank space with _ in str string, it will not update str string itself
str.replaceAll(' ', '_'); //this will replace ALL the black spaces with _


*str.substring(1, 10); //will return the string containing characters from index position 1 till 9(including) of str string


*to reverse a string in short
str.split("").reverse().join(""); //this will first convert the string to array with individual characters from the string and will
then reverse that array and will then join the reversed characters of array to convert it into string
bcz we cannot directly reverse string, but we can do in case of array


*str.trimEnd(), str.trimStart() can be used to trim spaces from starting and ending of the string

*typeof any function is function

*features of react
*difference between virtual dom and real dom
*what is babel
*difference between map and forEach
*difference between null and undefined
*explain event delegation
*difference between var, let and const
*project showcase and questions on it
*explain call, apply & bind methods
*infinite currying
*difference between local storage, session storage and cookies
*Implement promise.all
*Implement debouncing (with arguments)
*Implement throttling