*If we want to increase the value of each element of an array by 2 and we are using forEach loop to do so

arr.forEach((ar, index) => {
	ar = ar+2; //this won't do the needfull as 'ar' is like a temp variable which is just holding the array element one by one, therefore only
	//the value of temporary(ar) variable is getting increased
	arr[index] = ar+2;
	arr[index] = arr[index] + 2; //both the above one and this statement will do the work as this will update the array element
});


*let flattenedArr = [].concat(...arr); this will flaten the array 'arr' to one level
if we want to do it without concat function then we can do one level by simple forEach loop as well as follows:
let flattenedArr = [];
arr.forEach((ar)=>{
    flattenedArr.push(...ar);
});

*to flaten the array to multiple level we have a predefined method .flat
let flattenedArr = arr.flat(2); //if we want to flat the array 'arr' to two level

Custom flat method can be written in two ways, one with use of .concat and another without that, both of the methods you can see below

const customFlatFunction1 = (arr, depth) => {
    let resultArr = arr;
    for(let i=0; i<depth; i++){
        const tempArr = [];
        resultArr.forEach((ar, index)=>{
            if(typeof ar === "object")
                tempArr.push(...ar);
            else
                tempArr.push(ar);
        });
        resultArr = tempArr;
    }
    return resultArr;
}

//with .concat
const customFlatFunction2 = (arr, depth) => {
    let resultArr = arr;
    for(let i=0; i<depth; i++){
        resultArr = [].concat(...resultArr);
    }
    return resultArr;
}


*output question
for(var i=0; i<3; i++){
	setTimeout(function log(){
		console.log(i);
	}, i*1000);
}

output:
3
3
3

//why, bcz var is function scoped so everytime callback will store reference to the variable, so after the loop is finished and callback fn
comes back to the callstack then it will point to the current value of 'i' which is 3


In case of i being declared with 'let', let being block scope, it will send its scope with the callback function, which will then print
0
1
2


*Function composition is an approach where the result of one function is passed on to the next function, which is passed to 
another until the final function is executed for the final result.
compose function is a predefined function in some libraries which returns a function which we can use to perform multiple action at once
function addFive(a){
	return a+5;
}
function subtractTwo(a){
	return a-2;
}
function multiplyFour(a){
	return a*4;
}
const evaluate = compose(addFive, subtractTwo, multiplyFour); //evaluate will contain the function returned from compose fn
console.log(evaluate(5)); //23

what compose does is, when we pass parameter in it's returned function then first it will send that parameter to the last parameter
function (5 will go to multiplyFour) then result of that function is then passed to the next function (20 will go to subtractTwo)
similarly result keeps on going left and at last result is finally returned


*Pollyfill of compose function
function compose(...arguments){
	return (value)=>{
		let args = [...arguments];
		for(var i=args.length-1; i>=0; i--){
			value = args[i](value);
		}
		return value;
	}
}

as compose goes from back to front, there is one more function which is pipe which executes the function from start till end.


*Reverse the words in the provided sentence:
let abc=’My love is Javascript’;
console.log(abc.split(” “).reverse().join(” “))
OUTPUT:Javascript is love My


*Remove first character from the string
let str=”Hello,How are you”;
console.log(str.substring(1,str.length))
OUTPUT:ello,How are you


*Remove the duplicate elements from an array.
const arr = [1, 2, 3, 4, 4, 5,6];
const newArr = […new Set(arr)];
console.log(newArr);
OUTPUT:[1,2,3,4,5,6]


*How to prevent new properties from being added to an object
Object.seal(objName);


*Remove the duplicacy of the objects in an array
const arr=[{id:1,name:’one’},
{id:2,name:’two’},
{id:1,name:’one’},
{id:2,name:’two’},
{id:3,name:’three’}];
const map = {};
const newArray = [];
arr.forEach(el => {
if(!map[JSON.stringify(el)]){
map[JSON.stringify(el)] = true;
newArray.push(el);
}
});
console.log(newArray);
OUTPUT:[ { id: 1, name: ‘one’ },
{ id: 2, name: ‘two’ },
{ id: 3, name: ‘three’ } ]


*Question: How would you implement a function which if called like this sum(1)(2)(3)(4)....() returns me the sum of all the numbers passed?

Solution: let sum = function(a){
						return function(b){
									if(b){
										return sum(a+b);
									}
									return a;
								}
					}
this is a recursive function which will terminate when no argument will be passed.
	
*features of react
*difference between virtual dom and real dom
*what is babel
*difference between map and forEach
*difference between null and undefined
*explain event delegation
*difference between var, let and const
*project showcase and questions on it
*explain call, apply & bind methods
*infinite currying
*Implement promise.all
*Implement debouncing (with arguments)
*Implement throttling